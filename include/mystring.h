#ifndef INC_5E_MYSTRING_H
#define INC_5E_MYSTRING_H

#include <stdio.h>
#include <ctype.h>

// Максимальная длина строки
#define MAX_STRING_SIZE 255
// Максимальная длина одного слова (слово может занимать всю строку)
#define MAX_WORD_SIZE MAX_STRING_SIZE
// Максимальное кол-во слов в строке (между каждой парой слов должен стоять
// пробельный символ)
#define MAX_N_WORDS_IN_STRING ((MAX_STRING_SIZE + 1) / 2)

// Буфер для хранения промежуточных состояний строк
static char _string_buffer[MAX_STRING_SIZE + 1];

/*
 * begin - адрес первого символа слова
 * end - адрес ячейки памяти, следующей после последнего символа слова
 */
typedef struct WordDescriptor {
  char* begin;
  char* end;
} WordDescriptor;

/*
 * words - массив слов
 * size - кол-во слов в массиве
 */
typedef struct BagOfWords {
  WordDescriptor words[MAX_N_WORDS_IN_STRING];
  size_t size;
} BagOfWords;

// Первый буфер для хранения множества слов
static BagOfWords _bag_1;
// Второй буфер для хранения множества слов
static BagOfWords _bag_2;

/*
 * Возвращает 1, если в диапазоне [begin ... первый '\0'-символ) было найдено
 * слово, и записывает адрес первого символа слова в word.begin, а адрес ячейки
 * памяти, следующей после последнего символа слова в word.end, в противном случае
 * возвращает 0, в word.begin сохраняет адрес первого '\0'-символа, значение
 * word.end остается без изменений
 */
int getWord(char* begin_search,
            WordDescriptor* word);

/*
 * Возвращает 1, если в диапазоне (r_end_search ... r_begin_search] было
 * найдено слово, и записывает адрес первого символа слова в word.begin, а
 * адрес ячейки памяти, следующей после последнего символа слова в word.end,
 * в противном случае возвращает 0, в word.begin записывает значение
 * r_begin_search + 1, в word.end записывает r_end_search + 1
 */
int getWordReverse(char* r_end_search,
                   char* r_begin_search,
                   WordDescriptor* word);

/*
 * Возвращает положительное значение, если слово w_1 лексикографически стоит
 * после слова w_2, отрицательное значение, если слово w_1 лексикографически
 * стоит перед словом w_2, и ноль, если слова лексикографически равны
 * (возвращаемое значение по модулю численно равно разнице кодов
 * несовпадающих символов, в случае, когда строки различны, и 0, когда они
 * равны)
 */
int wordcmp(WordDescriptor w_1,
            WordDescriptor w_2);

/*
 * Выводит слово word в указанный поток out
 */
void fprintw(FILE* out,
             WordDescriptor word);

/*
 * Записывает все слова, найденные в диапазоне
 * [begin_search ... первый '\0'-символ) в массив bag.words, устанавливает
 * bag.size в значение, равное кол-ву найденных в строке слов
 */
void getBagOfWords(char* begin_search,
                   BagOfWords* bag);

/*
 * Возвращает кол-во символов, лежащих в диапазоне [begin ... первый '\0'-символ)
 */
size_t mystrlen(char* begin);

/*
 * Возвращает адрес первой ячейки памяти, содержащей символ ch и лежащей в
 * диапазоне [begin ... end), если ячейка, содержащая искомый символ была
 * найдена, в противном случае возвращает end
 */
char* find(char* begin,
           char* end,
           int ch);

/*
 * Возвращает адрес первой ячейки памяти, содержащей непробельный символ и
 * лежащей в диапазоне [begin ... первый '\0'-символ), если ячейка,
 * содержащая искомый символ была найдена, в противном случае возвращает
 * адрес первого '\0'-символа
 */
char* findNonSpace(char* begin);

/*
 * Возвращает адрес первой ячейки памяти, содержащей пробельный символ и
 * лежащей в диапазоне [begin ... первый '\0'-символ), если ячейка,
 * содержащая искомый символ была найдена, в противном случае возвращает
 * адрес первого '\0'-символа
 */
char* findSpace(char* begin);

/*
 * Возвращает адрес последней ячейки памяти, содержащей непробельный символ и
 * лежащей в диапазоне (r_end ... r_begin], если ячейка,
 * содержащая искомый символ была найдена, в противном случае возвращает r_end
 */
char* findNonSpaceReverse(char* r_end,
                          char* r_begin);

/*
 * Возвращает адрес последней ячейки памяти, содержащей пробельный символ и
 * лежащей в диапазоне (r_end ... r_begin], если ячейка,
 * содержащая искомый символ была найдена, в противном случае возвращает r_end
 */
char* findSpaceReverse(char* r_end,
                       char* r_begin);

/*
 * Возвращает положительное значение, если строка lhs лексикографически стоит
 * после строки rhs, отрицательное значение, если строка lhs лексикографически
 * стоит перед строкой rhs, и ноль, если строки лексикографически равны
 * (возвращаемое значение по модулю численно равно разнице кодов
 * несовпадающих символов, в случае, когда строки различны, и 0, когда они
 * равны)
 */
int mystrcmp(char* lhs,
             char* rhs);

/*
 * Возвращает указатель на ячейку памяти, свободную для записи и следующую
 * сразу за последним символом, записанным в строку begin_dst в результате
 * копирования символов из диапазона [begin_src ... end_src) в область
 * памяти, начинающуюся с begin_dst включительно
 */
char* copy(char* begin_src,
           char* end_src,
           char* begin_dst);

/*
 * Возвращает указатель на ячейку памяти, свободную для записи и следующую
 * сразу за последним символом, записанным в строку begin_dst в результате
 * копирования в обратном порядке символов из диапазона (r_end_src ...
 * r_begin_src] в область памяти, начинающуюся с begin_dst включительно
 */
char* copyReverse(char* r_end_src,
                  char* r_begin_src,
                  char* begin_dst);

/*
 * Возвращает указатель на ячейку памяти, свободную для записи и следующую
 * сразу за последним символом, записанным в строку begin_dst в результате
 * копирования символов из диапазона [begin_src ... end_src), удовлетворяющих
 * условию condition, в область памяти, начинающуюся с begin_dst включительно
 */
char* copyIf(char* begin_src,
             char* end_src,
             char* begin_dst,
             int (* condition)(int));

/*
 * Возвращает указатель на ячейку памяти, свободную для записи и следующую
 * сразу за последним символом, записанным в строку begin_dst в результате
 * копирования в обратном порядке символов из диапазона (r_end_src ...
 * r_begin_src], удовлетворяющих условию condition, в область памяти,
 * начинающуюся с begin_dst включительно
 */
char* copyIfReverse(char* r_end_src,
                    char* r_begin_src,
                    char* begin_dst,
                    int (* condition)(int));

/*
 * преобразовывает слово word в строку dst, дописывает в конец строки
 * '\0'-символ
 */
void wordDescriptorToString(WordDescriptor word,
                            char* dst);

#endif // INC_5E_MYSTRING_H
