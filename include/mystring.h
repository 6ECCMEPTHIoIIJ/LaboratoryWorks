#ifndef INC_5E_MYSTRING_H
#define INC_5E_MYSTRING_H

#include <stdio.h>
#include <ctype.h>

#define MAX_STRING_SIZE 255

static char _string_buffer[MAX_STRING_SIZE + 1];

/*
 * begin - адрес первого символа слова
 * end - адрес ячейки памяти, следующей после последнего символа слова
 */
typedef struct WordDescriptor {
  char* begin;
  char* end;
} WordDescriptor;

/*
 * Возвращает 1, если в диапазоне [begin ... первый '\0'-символ) было найдено
 * слово, и записывает адрес первого символа слова в word.begin, а адрес ячейки
 * памяти, следующей после последнего символа слова в word.end, в противном случае
 * возвращает 0, оставляет word без изменений
 */
int getWord(char* begin_search,
            WordDescriptor* word);

/*
 * Возвращает 1, если в диапазоне (r_end_search ... r_begin_search] было
 * найдено слово, и записывает адрес первого символа слова в word.begin, а
 * адрес ячейки памяти, следующей после последнего символа слова в word.end,
 * в противном случае возвращает 0, оставляет word без изменений
 */
int getWordReverse(char* r_end_search,
                   char* r_begin_search,
                   WordDescriptor* word);

/*
 * Возвращает кол-во символов, лежащих в диапазоне [begin ... первый '\0'-символ)
 */
size_t mystrlen(char* begin);

/*
 * Возвращает адрес первой ячейки памяти, содержащей символ ch и лежащей в
 * диапазоне [begin ... end), если ячейка, содержащая искомый символ была
 * найдена, в противном случае возвращает end
 */
char* find(char* begin,
           char* end,
           int ch);

/*
 * Возвращает адрес первой ячейки памяти, содержащей непробельный символ и
 * лежащей в диапазоне [begin ... первый '\0'-символ), если ячейка,
 * содержащая искомый символ была найдена, в противном случае возвращает
 * адрес первого '\0'-символа
 */
char* findNonSpace(char* begin);

/*
 * Возвращает адрес первой ячейки памяти, содержащей пробельный символ и
 * лежащей в диапазоне [begin ... первый '\0'-символ), если ячейка,
 * содержащая искомый символ была найдена, в противном случае возвращает
 * адрес первого '\0'-символа
 */
char* findSpace(char* begin);

/*
 * Возвращает адрес последней ячейки памяти, содержащей непробельный символ и
 * лежащей в диапазоне (r_end ... r_begin], если ячейка,
 * содержащая искомый символ была найдена, в противном случае возвращает r_end
 */
char* findNonSpaceReverse(char* r_end,
                          char* r_begin);

/*
 * Возвращает адрес последней ячейки памяти, содержащей пробельный символ и
 * лежащей в диапазоне (r_end ... r_begin], если ячейка,
 * содержащая искомый символ была найдена, в противном случае возвращает r_end
 */
char* findSpaceReverse(char* r_end,
                       char* r_begin);

/*
 * Возвращает положительное значение, если строка lhs лексикографически стоит
 * после строки rhs, отрицательное значение, если строка lhs лексикографически
 * стоит перед строкой rhs, и ноль, если строки лексикографически равны
 * (возвращаемое значение по модулю численно равно разнице кодов
 * несовпадающих символов, в случае, когда строки различны, и 0, когда они
 * равны)
 */
int mystrcmp(char* lhs,
             char* rhs);

/*
 * Возвращает указатель на ячейку памяти, свободную для записи и следующую
 * сразу за последним символом, записанным в строку begin_dst в результате
 * копирования символов из диапазона [begin_src ... end_src) в область
 * памяти, начинающуюся с begin_dst включительно
 */
char* copy(char* begin_src,
           char* end_src,
           char* begin_dst);

/*
 * Возвращает указатель на ячейку памяти, свободную для записи и следующую
 * сразу за последним символом, записанным в строку begin_dst в результате
 * копирования символов из диапазона [begin_src ... end_src), удовлетворяющих
 * условию condition, в область памяти, начинающуюся с begin_dst включительно
 */
char* copyIf(char* begin_src,
             char* end_src,
             char* begin_dst,
             int (* condition)(int));

/*
 * Возвращает указатель на ячейку памяти, свободную для записи и следующую
 * сразу за последним символом, записанным в строку begin_dst в результате
 * копирования в обратном порядке символов из диапазона (r_end_src ...
 * r_begin_src], удовлетворяющих условию condition, в область памяти,
 * начинающуюся с begin_dst включительно
 */
char* copyIfReverse(char* r_end_src,
                    char* r_begin_src,
                    char* begin_dst,
                    int (* condition)(int));

#endif // INC_5E_MYSTRING_H
