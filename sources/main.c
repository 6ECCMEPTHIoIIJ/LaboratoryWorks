#include "../include/matrix.h"
#include <assert.h>
#include <malloc.h>
#include <minmax.h>

//#define TEST_MATRIX
//#define TASK_1
//#define TASK_2
//#define TASK_3
//#define TASK_4
//#define TASK_5
//#define TASK_6
//#define TASK_7
//#define TASK_8
//#define TASK_9
//#define TASK_10
//#define TASK_11
//#define TASK_12
//#define TASK_13
//#define TASK_14
//#define TASK_15
//#define TASK_16
//#define TASK_17
#define TASK_18

//	–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—Å–Ω–æ–≤–Ω—ã—Ö —Ñ—É–Ω–∫—Ü–∏–π –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ matrix.h
#ifdef TEST_MATRIX

#include "../include/matrix_tests.h"

int main() {
  test_matrix();

  return 0;
}

#endif // TEST_MATRIX

//	–î–∞–Ω–∞ –∫–≤–∞–¥—Ä–∞—Ç–Ω–∞—è –º–∞—Ç—Ä–∏—Ü–∞, –≤—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã –∫–æ—Ç–æ—Ä–æ–π —Ä–∞–∑–ª–∏—á–Ω—ã. –ü–æ–º–µ–Ω—è—Ç—å –º–µ—Å—Ç–∞–º–∏
//	—Å—Ç—Ä–æ–∫–∏, –≤ –∫–æ—Ç–æ—Ä—ã—Ö –Ω–∞—Ö–æ–¥—è—Ç—Å—è –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π –∏ –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç—ã.
#ifdef TASK_1

/**
 * @brief –û–±–º–µ–Ω —Å—Ç—Ä–æ–∫ –º–∞—Ç—Ä–∏—Ü—ã, —Å–æ–¥–µ—Ä–∂–∞—â–∏—Ö –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –∏ –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç—ã
 *
 * @param m –º–∞—Ç—Ä–∏—Ü–∞
 */
void SwapRowsWithMinMaxEls(Matrix m) {
  SwapRows(m, GetMinValuePos(m).row_i, GetMaxValuePos(m).row_i);
}

static void test_SwapRowsWithMinMaxEls_DiffRows() {
  printf("[--------] DiffRows\n");
  const size_t kInitialNRows = 3;
  const size_t kInitialNCols = 3;
  int initial_arr[] = {1, 2, 3,
                       4, 5, 6,
                       7, 8, 9};
  int expected_arr[] = {7, 8, 9,
                        4, 5, 6,
                        1, 2, 3};
  Matrix m = CreateMatrixFromArray(initial_arr, kInitialNRows,
                                   kInitialNCols);
  Matrix expected_m = CreateMatrixFromArray(expected_arr, kInitialNRows,
                                            kInitialNCols);
  printf("[--------] n_rows = %zu, n_cols = %zu\n",
         kInitialNRows,
         kInitialNCols);
  printf("[RUN     ]\n");
  SwapRowsWithMinMaxEls(m);
  assert(AreTwoMatricesEqual(m, expected_m));

  FreeMemMatrix(&m);
  FreeMemMatrix(&expected_m);
  printf("[      OK]\n");
}

static void test_SwapRowsWithMinMaxEls_OneRow() {
  printf("[--------] OneRow\n");
  const size_t kInitialNRows = 3;
  const size_t kInitialNCols = 3;
  int initial_arr[] = {1, 2, 3,
                       4, 5, 6,
                       -6, 8, 9};
  int expected_arr[] = {1, 2, 3,
                        4, 5, 6,
                        -6, 8, 9};
  Matrix m = CreateMatrixFromArray(initial_arr, kInitialNRows,
                                   kInitialNCols);
  Matrix expected_m = CreateMatrixFromArray(expected_arr, kInitialNRows,
                                            kInitialNCols);
  printf("[--------] n_rows = %zu, n_cols = %zu\n",
         kInitialNRows,
         kInitialNCols);
  printf("[RUN     ]\n");
  SwapRowsWithMinMaxEls(m);
  assert(AreTwoMatricesEqual(m, expected_m));

  FreeMemMatrix(&m);
  FreeMemMatrix(&expected_m);
  printf("[      OK]\n");
}

static void test_SwapRowsWithMinMaxEls() {
  printf("[========] %s()\n", __FUNCTION__);
  test_SwapRowsWithMinMaxEls_DiffRows();
  test_SwapRowsWithMinMaxEls_OneRow();
}

int main() {
  test_SwapRowsWithMinMaxEls();

  return 0;
}

#endif // TASK_1

//	–£–ø–æ—Ä—è–¥–æ—á–∏—Ç—å —Å—Ç—Ä–æ–∫–∏ –º–∞—Ç—Ä–∏—Ü—ã –ø–æ –Ω–µ—É–±—ã–≤–∞–Ω–∏—é –Ω–∞–∏–±–æ–ª—å—à–∏—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤ —Å—Ç—Ä–æ–∫:
#ifdef TASK_2

/**
 * @brief –ü–æ–∏—Å–∫ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –º–∞—Å—Å–∏–≤–∞
 *
 * @param arr		—É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ –Ω—É–ª–µ–≤–æ–π —ç–ª–µ–º–µ–Ω—Ç –º–∞—Å—Å–∏–≤–∞
 * @param size	–∫–æ–ª-–≤–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –º–∞—Å—Å–∏–≤–∞
 * @return	–º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –º–∞—Å—Å–∏–≤–∞
 */
int GetMax(int* arr,
           const size_t size) {
  int max = arr[0];
  for (size_t i = 0; i < size; i++) {
    if (arr[i] > max) {
      max = arr[i];
    }
  }

  return max;
}

/**
 * @brief –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ —Å—Ç—Ä–æ–∫ –º–∞—Ç—Ä–∏—Ü—ã –ø–æ –Ω–µ—É–±—ã–≤–∞–Ω–∏—é –∑–Ω–∞—á–µ–Ω–∏–π –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã—Ö
 * 				—ç–ª–µ–º–µ–Ω—Ç–æ–≤ —Å—Ç—Ä–æ–∫
 *
 * @param m –º–∞—Ç—Ä–∏—Ü–∞
 */
void sortRowsByMaxElement(Matrix m) {
  InsertionSortRowsMatrixByRowCriteria(m, GetMax);
}

static void test_sortRowsByMaxElement_Unsorted() {
  printf("[--------] Unsorted\n");
  const size_t kInitialNRows = 3;
  const size_t kInitialNCols = 3;
  int initial_arr[] = {1, -7, 9,
                       0, 128, 11,
                       -123, -1, -4};
  int expected_arr[] = {-123, -1, -4,
                        1, -7, 9,
                        0, 128, 11};
  Matrix m = CreateMatrixFromArray(initial_arr, kInitialNRows,
                                   kInitialNCols);
  Matrix expected_m = CreateMatrixFromArray(expected_arr, kInitialNRows,
                                            kInitialNCols);
  printf("[--------] n_rows = %zu, n_cols = %zu\n",
         kInitialNRows,
         kInitialNCols);
  printf("[RUN     ]\n");
  sortRowsByMaxElement(m);
  assert(AreTwoMatricesEqual(m, expected_m));

  FreeMemMatrix(&m);
  FreeMemMatrix(&expected_m);
  printf("[      OK]\n");
}

static void test_sortRowsByMaxElement_Sorted() {
  printf("[--------] Sorted\n");
  const size_t kInitialNRows = 3;
  const size_t kInitialNCols = 3;
  int initial_arr[] = {1, 2, 3,
                       4, 5, 6,
                       7, 8, 9};
  int expected_arr[] = {1, 2, 3,
                        4, 5, 6,
                        7, 8, 9};
  Matrix m = CreateMatrixFromArray(initial_arr, kInitialNRows,
                                   kInitialNCols);
  Matrix expected_m = CreateMatrixFromArray(expected_arr, kInitialNRows,
                                            kInitialNCols);
  printf("[--------] n_rows = %zu, n_cols = %zu\n",
         kInitialNRows,
         kInitialNCols);
  printf("[RUN     ]\n");
  sortRowsByMaxElement(m);
  assert(AreTwoMatricesEqual(m, expected_m));

  FreeMemMatrix(&m);
  FreeMemMatrix(&expected_m);
  printf("[      OK]\n");
}

static void test_sortRowsByMaxElement() {
  printf("[========] %s()\n", __FUNCTION__);
  test_sortRowsByMaxElement_Unsorted();
  test_sortRowsByMaxElement_Sorted();
}

int main() {
  test_sortRowsByMaxElement();

  return 0;
}

#endif // TASK_2

//	–î–∞–Ω–∞ –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∞—è –º–∞—Ç—Ä–∏—Ü–∞. –£–ø–æ—Ä—è–¥–æ—á–∏—Ç—å —Å—Ç–æ–ª–±—Ü—ã –º–∞—Ç—Ä–∏—Ü—ã –ø–æ –Ω–µ—É–±—ã–≤–∞–Ω–∏—é
//	–º–∏–Ω–∏–º–∞–ª—å–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤ —Å—Ç–æ–ª–±—Ü–æ–≤:
#ifdef TASK_3

/**
 * @brief –ü–æ–∏—Å–∫ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –º–∞—Å—Å–∏–≤–∞
 *
 * @param arr		—É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ –Ω—É–ª–µ–≤–æ–π —ç–ª–µ–º–µ–Ω—Ç –º–∞—Å—Å–∏–≤–∞
 * @param size	–∫–æ–ª-–≤–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –º–∞—Å—Å–∏–≤–∞
 * @return	–º–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –º–∞—Å—Å–∏–≤–∞
 */
int GetMin(int* arr,
           const size_t size) {
  int min = arr[0];
  for (size_t i = 0; i < size; i++) {
    if (arr[i] < min) {
      min = arr[i];
    }
  }

  return min;
}

/**
 * @brief –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ —Å—Ç—Ä–æ–∫ –º–∞—Ç—Ä–∏—Ü—ã –ø–æ –Ω–µ—É–±—ã–≤–∞–Ω–∏—é –∑–Ω–∞—á–µ–Ω–∏–π –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã—Ö
 * 				—ç–ª–µ–º–µ–Ω—Ç–æ–≤ —Å—Ç—Ä–æ–∫
 *
 * @param m –º–∞—Ç—Ä–∏—Ü–∞
 */
void SortColsByMinElement(Matrix m) {
  InsertionSortColsMatrixByColCriteria(m, GetMin);
}

static void test_SortColsByMinElement_Unsorted() {
  printf("[--------] Unsorted\n");
  const size_t kInitialNRows = 3;
  const size_t kInitialNCols = 6;
  int initial_arr[] = {3, 5, 2, 4, 3, 3,
                       2, 5, 1, 8, 2, 7,
                       6, 1, 4, 4, 8, 3};
  int expected_arr[] = {5, 2, 3, 3, 3, 4,
                        5, 1, 2, 2, 7, 8,
                        1, 4, 6, 8, 3, 4};
  Matrix m = CreateMatrixFromArray(initial_arr, kInitialNRows,
                                   kInitialNCols);
  Matrix expected_m = CreateMatrixFromArray(expected_arr, kInitialNRows,
                                            kInitialNCols);
  printf("[--------] n_rows = %zu, n_cols = %zu\n",
         kInitialNRows,
         kInitialNCols);
  printf("[RUN     ]\n");
  SortColsByMinElement(m);
  assert(AreTwoMatricesEqual(m, expected_m));

  FreeMemMatrix(&m);
  FreeMemMatrix(&expected_m);
  printf("[      OK]\n");
}

static void test_SortColsByMinElement_Sorted() {
  printf("[--------] Sorted\n");
  const size_t kInitialNRows = 3;
  const size_t kInitialNCols = 3;
  int initial_arr[] = {1, -7, 9,
                       0, 128, 11,
                       -123, -1, -4};
  int expected_arr[] = {1, -7, 9,
                        0, 128, 11,
                        -123, -1, -4};
  Matrix m = CreateMatrixFromArray(initial_arr, kInitialNRows,
                                   kInitialNCols);
  Matrix expected_m = CreateMatrixFromArray(expected_arr, kInitialNRows,
                                            kInitialNCols);
  printf("[--------] n_rows = %zu, n_cols = %zu\n",
         kInitialNRows,
         kInitialNCols);
  printf("[RUN     ]\n");
  SortColsByMinElement(m);
  assert(AreTwoMatricesEqual(m, expected_m));

  FreeMemMatrix(&m);
  FreeMemMatrix(&expected_m);
  printf("[      OK]\n");
}

static void test_SortRowsByMaxElement() {
  printf("[========] %s()\n", __FUNCTION__);
  test_SortColsByMinElement_Unsorted();
  test_SortColsByMinElement_Sorted();
}

int main() {
  test_SortRowsByMaxElement();

  return 0;
}

#endif // TASK_3

//	–ï—Å–ª–∏ –¥–∞–Ω–Ω–∞—è –∫–≤–∞–¥—Ä–∞—Ç–Ω–∞—è –º–∞—Ç—Ä–∏—Ü–∞ ùê¥ —Å–∏–º–º–µ—Ç—Ä–∏—á–Ω–∞, —Ç–æ –∑–∞–º–µ–Ω–∏—Ç—å ùê¥ –µ–µ –∫–≤–∞–¥—Ä–∞—Ç–æ–º (ùê¥2)
#ifdef TASK_4

/**
 * @brief –í–æ–∑–≤–µ–¥–µ–Ω–∏–µ –≤ –∫–≤–∞–¥—Ä–∞—Ç —Å–∏–º–º–µ—Ç—Ä–∏—á–Ω–æ–π –º–∞—Ç—Ä–∏—Ü—ã. –ï—Å–ª–∏ –º–∞—Ç—Ä–∏—Ü–∞
 * 				–Ω–µ—Å–∏–º–º–µ—Ç—Ä–∏—á–Ω–∞, —Ç–æ –µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –Ω–µ –º–µ–Ω—è–µ—Ç—Å—è
 * @param m	—É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ –º–∞—Ç—Ä–∏—Ü—É
 */
void GetSquareOfMatrixIfSymmetric(Matrix* m) {
  if (IsSymmetricMatrix(*m)) {
    Matrix t = MulMatrices(*m, *m);
    FreeMemMatrix(m);
    *m = t;
  }
}

static void test_GetSquareOfMatrixIfSymmetric_Square() {
  printf("[--------] Square\n");
  const size_t kInitialNRows = 3;
  const size_t kInitialNCols = 3;
  int initial_arr[] = {1, 0, 0,
                       0, 2, 0,
                       0, 0, 13};
  int expected_arr[] = {1, 0, 0,
                        0, 4, 0,
                        0, 0, 169};
  Matrix m = CreateMatrixFromArray(initial_arr, kInitialNRows,
                                   kInitialNCols);
  Matrix expected_m = CreateMatrixFromArray(expected_arr, kInitialNRows,
                                            kInitialNCols);
  printf("[--------] n_rows = %zu, n_cols = %zu\n",
         kInitialNRows,
         kInitialNCols);
  printf("[RUN     ]\n");
  GetSquareOfMatrixIfSymmetric(&m);
  assert(AreTwoMatricesEqual(m, expected_m));

  FreeMemMatrix(&m);
  FreeMemMatrix(&expected_m);
  printf("[      OK]\n");
}

static void test_GetSquareOfMatrixIfSymmetric_NotSquare() {
  printf("[--------] NotSquare\n");
  const size_t kInitialNRows = 4;
  const size_t kInitialNCols = 3;
  int initial_arr[] = {1, 0, 0,
                       0, 7, 0,
                       0, 0, 1,
                       9, 8, 7};
  int expected_arr[] = {1, 0, 0,
                        0, 7, 0,
                        0, 0, 1,
                        9, 8, 7};
  Matrix m = CreateMatrixFromArray(initial_arr, kInitialNRows,
                                   kInitialNCols);
  Matrix expected_m = CreateMatrixFromArray(expected_arr, kInitialNRows,
                                            kInitialNCols);
  printf("[--------] n_rows = %zu, n_cols = %zu\n",
         kInitialNRows,
         kInitialNCols);
  printf("[RUN     ]\n");
  GetSquareOfMatrixIfSymmetric(&m);
  assert(AreTwoMatricesEqual(m, expected_m));

  FreeMemMatrix(&m);
  FreeMemMatrix(&expected_m);
  printf("[      OK]\n");
}

static void test_GetSquareOfMatrixIfSymmetric() {
  printf("[========] %s()\n", __FUNCTION__);
  test_GetSquareOfMatrixIfSymmetric_Square();
  test_GetSquareOfMatrixIfSymmetric_NotSquare();
}

int main() {
  test_GetSquareOfMatrixIfSymmetric();

  return 0;
}

#endif // TASK_4

// 	–î–∞–Ω–∞ –∫–≤–∞–¥—Ä–∞—Ç–Ω–∞—è –º–∞—Ç—Ä–∏—Ü–∞. –ï—Å–ª–∏ —Å—Ä–µ–¥–∏ —Å—É–º–º —ç–ª–µ–º–µ–Ω—Ç–æ–≤ —Å—Ç—Ä–æ–∫ –º–∞—Ç—Ä–∏—Ü—ã –Ω–µ—Ç —Ä–∞–≤–Ω—ã—Ö,
// 	—Ç–æ —Ç—Ä–∞–Ω—Å–ø–æ–Ω–∏—Ä–æ–≤–∞—Ç—å –º–∞—Ç—Ä–∏—Ü—É.
#ifdef TASK_5

/**
 * @brief –í—ã—á–∏—Å–ª–µ–Ω–∏–µ —Å—É–º–º—ã —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –º–∞—Å—Å–∏–≤–∞
 *
 * @param arr 	—É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ –ø–µ—Ä–≤—ã–π —ç–ª–µ–º–µ–Ω—Ç –º–∞—Å—Å–∏–≤–∞
 * @param size 	–∫–æ–ª-–≤–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –º–∞—Å—Å–∏–≤–∞
 * @return —Å—É–º–º—É —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –º–∞—Å—Å–∏–≤–∞
 */
long long GetSum(int* arr,
                 const size_t size) {
  long long sum = 0;
  for (size_t i = 0; i < size; i++) {
    sum += arr[i];
  }

  return sum;
}

/**
 * @brief –ü–æ–∏—Å–∫ –∏–Ω–¥–µ–∫—Å–∞ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞ –º–∞—Å—Å–∏–≤–∞
 * @param arr 	—É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ –Ω—É–ª–µ–≤–æ–π —ç–ª–µ–º–µ–Ω—Ç –º–∞—Å—Å–∏–≤–∞
 * @param size 	–∫–æ–ª-–≤–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –º–∞—Å—Å–∏–≤–∞
 * @param el 		–∏—Å–∫–æ–º–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
 * @return –∏–Ω–¥–µ–∫—Å –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞ –º–∞—Å—Å–∏–≤–∞
 */
size_t Find(long long* arr,
            const size_t size,
            const long long el) {
  for (size_t i = 0; i < size; i++) {
    if (arr[i] == el) {
      return i;
    }
  }

  return size;
}

/**
 * @brief –ü—Ä–æ–≤–µ—Ä–∫–∞ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –º–∞—Å—Å–∏–≤–∞ –Ω–∞ —É–Ω–∏–∫–∞–ª—å–Ω–æ—Å—Ç—å
 * @param arr 	—É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ –ø–µ—Ä–≤—ã–π —ç–ª–µ–º–µ–Ω—Ç –º–∞—Å—Å–∏–≤–∞
 * @param size 	–∫–æ–ª-–≤–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –º–∞—Å—Å–∏–≤–∞
 * @return		'true', –µ—Å–ª–∏ —ç–ª–µ–º–µ–Ω—Ç—ã –º–∞—Å—Å–∏–≤–∞ —É–Ω–∏–∫–∞–ª—å–Ω—ã,
 * 						'false' –≤ –ø—Ä–æ—Ç–∏–≤–Ω–æ–º —Å–ª—É—á–∞–µ
 */
bool IsUnique(long long* arr,
              const size_t size) {
  for (size_t i = 0; i < size; i++) {
    const size_t pos = Find(arr, size, arr[i]);
    if (pos != i && pos != size) {
      return false;
    }
  }

  return true;
}

/**
 * @brief –¢—Ä–∞–Ω—Å–ø–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –º–∞—Ç—Ä–∏—Ü—ã, –Ω–µ –∏–º–µ—é—â–µ–π —Å—Ç—Ä–æ–∫ —Å –æ–¥–∏–Ω–∞–∫–æ–≤–æ–π —Å—É–º–º–æ–π
 * 				—ç–ª–µ–º–µ–Ω—Ç–æ–≤. –ï—Å–ª–∏ —Å—Ç—Ä–æ–∫–∏ —Å –æ–¥–∏–Ω–∞–∫–æ–≤–æ–π —Å—É–º–º–æ–π –∏–º–µ—é—Ç—Å—è, —Ç–æ –∑–Ω–∞—á–µ–Ω–∏–µ
 * 				–º–∞—Ç—Ä–∏—Ü—ã –Ω–µ –º–µ–Ω—è–µ—Ç—Å—è
 * @param m —É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ –º–∞—Ç—Ä–∏—Ü—É
 */
void TransposeIfMatrixHasNotEqualSunOfRows(Matrix* m) {
  long long* row_sums = (long long*) malloc(m->n_rows * sizeof(*row_sums));
  for (size_t row_i = 0; row_i < m->n_rows; row_i++) {
    row_sums[row_i] = GetSum(m->data[row_i], m->n_cols);
  }

  if (IsUnique(row_sums, m->n_rows)) {
    TransposeMatrix(m);
  }
}

static void test_TransposeIfMatrixHasNotEqualSunOfRows_NotEqual() {
  printf("[--------] NotEqual\n");
  const size_t kInitialNRows = 4;
  const size_t kInitialNCols = 3;
  int initial_arr[] = {1, 0, 0,
                       0, 7, 0,
                       0, 0, 2,
                       9, 8, 7};
  int expected_arr[] = {1, 0, 0, 9,
                        0, 7, 0, 8,
                        0, 0, 2, 7};
  Matrix m = CreateMatrixFromArray(initial_arr, kInitialNRows,
                                   kInitialNCols);
  Matrix expected_m = CreateMatrixFromArray(expected_arr, kInitialNCols,
                                            kInitialNRows);
  printf("[--------] n_rows = %zu, n_cols = %zu\n",
         kInitialNRows,
         kInitialNCols);
  printf("[RUN     ]\n");
  TransposeIfMatrixHasNotEqualSunOfRows(&m);
  assert(AreTwoMatricesEqual(m, expected_m));

  FreeMemMatrix(&m);
  FreeMemMatrix(&expected_m);
  printf("[      OK]\n");
}

static void test_TransposeIfMatrixHasNotEqualSunOfRows_HasEqual() {
  printf("[--------] HasEqual\n");
  const size_t kInitialNRows = 4;
  const size_t kInitialNCols = 3;
  int initial_arr[] = {1, 0, 0,
                       0, 7, 0,
                       0, 0, 1,
                       9, 8, 7};
  int expected_arr[] = {1, 0, 0,
                        0, 7, 0,
                        0, 0, 1,
                        9, 8, 7};
  Matrix m = CreateMatrixFromArray(initial_arr, kInitialNRows,
                                   kInitialNCols);
  Matrix expected_m = CreateMatrixFromArray(expected_arr, kInitialNRows,
                                            kInitialNCols);
  printf("[--------] n_rows = %zu, n_cols = %zu\n",
         kInitialNRows,
         kInitialNCols);
  printf("[RUN     ]\n");
  TransposeIfMatrixHasNotEqualSunOfRows(&m);
  assert(AreTwoMatricesEqual(m, expected_m));

  FreeMemMatrix(&m);
  FreeMemMatrix(&expected_m);
  printf("[      OK]\n");
}

static void test_TransposeIfMatrixHasNotEqualSunOfRows() {
  printf("[========] %s()\n", __FUNCTION__);
  test_TransposeIfMatrixHasNotEqualSunOfRows_HasEqual();
  test_TransposeIfMatrixHasNotEqualSunOfRows_NotEqual();
}

int main() {
  test_TransposeIfMatrixHasNotEqualSunOfRows();

  return 0;
}

#endif // TASK_5

//	–î–∞–Ω—ã –¥–≤–µ –∫–≤–∞–¥—Ä–∞—Ç–Ω—ã–µ –º–∞—Ç—Ä–∏—Ü—ã ùê¥ –∏ ùêµ. –û–ø—Ä–µ–¥–µ–ª–∏—Ç—å, —è–≤–ª—è—é—Ç—Å—è –ª–∏ –æ–Ω–∏ –≤–∑–∞–∏–º–Ω–æ
//	–æ–±—Ä–∞—Ç–Ω—ã–º–∏
#ifdef TASK_6

/**
 * @brief –ü—Ä–æ–≤–µ—Ä–∫–∞, —è–≤–ª—è—é—Ç—Å—è –ª–∏ –º–∞—Ç—Ä–∏—Ü—ã –≤–∑–∞–∏–º–æ–æ–±—Ä–∞—Ç–Ω—ã–º–∏
 * @param m_1	–ø–µ—Ä–≤–∞—è –º–∞—Ç—Ä–∏—Ü–∞
 * @param m_2	–≤—Ç–æ—Ä–∞—è –º–∞—Ç—Ä–∏—Ü–∞
 * @return	'true', –µ—Å–ª–∏ –º–∞—Ç—Ä–∏—Ü—ã –≤–∑–∞–∏–º–æ–æ–±—Ä–∞—Ç–Ω—ã–µ,
 * 					'false' –≤ –ø—Ä–æ—Ç–∏–≤–Ω–æ–º —Å–ª—É—á–∞–µ
 */
bool IsMutuallyInverseMatrices(const Matrix m_1,
                               const Matrix m_2) {
  if (!(IsSquareMatrix(m_1) &&
        (m_1.n_rows == m_2.n_rows &&
         m_1.n_cols == m_2.n_cols))) {
    return false;
  }

  Matrix e = MulMatrices(m_1, m_2);

  if (IsEMatrix(e)) {
    FreeMemMatrix(&e);
    return true;
  } else {
    return false;
  }
}

static void test_IsMutuallyInverseMatrices_True() {
  printf("[--------] True\n");
  const size_t kInitialNRows = 3;
  const size_t kInitialNCols = 3;
  int initial_arr_1[] = {1, 0, 0,
                         0, 1, 0,
                         0, 0, 1};
  int initial_arr_2[] = {1, 0, 0,
                         0, 1, 0,
                         0, 0, 1};
  Matrix m_1 = CreateMatrixFromArray(initial_arr_1, kInitialNRows,
                                     kInitialNCols);
  Matrix m_2 = CreateMatrixFromArray(initial_arr_2, kInitialNRows,
                                     kInitialNCols);
  printf("[--------] n_rows = %zu, n_cols = %zu\n",
         kInitialNRows,
         kInitialNCols);
  printf("[RUN     ]\n");
  assert(IsMutuallyInverseMatrices(m_1, m_2));

  FreeMemMatrix(&m_1);
  FreeMemMatrix(&m_2);
  printf("[      OK]\n");
}

static void test_IsMutuallyInverseMatrices_False() {
  printf("[--------] False\n");
  const size_t kInitialNRows = 3;
  const size_t kInitialNCols = 3;
  int initial_arr_1[] = {1, 0, 0,
                         0, 1, 0,
                         0, 0, 1};
  int initial_arr_2[] = {2, 0, 0,
                         0, 2, 0,
                         0, 0, 2};
  Matrix m_1 = CreateMatrixFromArray(initial_arr_1, kInitialNRows,
                                     kInitialNCols);
  Matrix m_2 = CreateMatrixFromArray(initial_arr_2, kInitialNRows,
                                     kInitialNCols);
  printf("[--------] n_rows = %zu, n_cols = %zu\n",
         kInitialNRows,
         kInitialNCols);
  printf("[RUN     ]\n");
  assert(!IsMutuallyInverseMatrices(m_1, m_2));

  FreeMemMatrix(&m_1);
  FreeMemMatrix(&m_2);
  printf("[      OK]\n");
}

static void test_IsMutuallyInverseMatrices_DiffSizes() {
  printf("[--------] DiffSizes\n");
  const size_t kInitialNRows1 = 3;
  const size_t kInitialNCols1 = 3;
  const size_t kInitialNRows2 = 4;
  const size_t kInitialNCols2 = 3;
  int initial_arr_1[] = {1, 0, 0,
                         0, 1, 0,
                         0, 0, 1};
  int initial_arr_2[] = {2, 0, 0,
                         0, 2, 0,
                         0, 0, 2,
                         0, 0, 0};
  Matrix m_1 = CreateMatrixFromArray(initial_arr_1, kInitialNRows1,
                                     kInitialNCols1);
  Matrix m_2 = CreateMatrixFromArray(initial_arr_2, kInitialNRows2,
                                     kInitialNCols2);
  printf("[--------] n_rows_1 = %zu, n_cols_1 = %zu,"
         "n_rows_2 = %zu, n_cols_2 = %zu\n",
         kInitialNRows1,
         kInitialNCols1,
         kInitialNRows2,
         kInitialNCols2);
  printf("[RUN     ]\n");
  assert(!IsMutuallyInverseMatrices(m_1, m_2));

  FreeMemMatrix(&m_1);
  FreeMemMatrix(&m_2);
  printf("[      OK]\n");
}

static void test_IsMutuallyInverseMatrices() {
  printf("[========] %s()\n", __FUNCTION__);
  test_IsMutuallyInverseMatrices_DiffSizes();
  test_IsMutuallyInverseMatrices_False();
  test_IsMutuallyInverseMatrices_True();
}

int main() {
  test_IsMutuallyInverseMatrices();

  return 0;
}

#endif // TASK_6

//	–î–∞–Ω–∞ –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∞—è –º–∞—Ç—Ä–∏—Ü–∞. –ù–∞–∑–æ–≤–µ–º –ø—Å–µ–≤–¥–æ–¥–∏–∞–≥–æ–Ω–∞–ª—å—é –º–Ω–æ–∂–µ—Å—Ç–≤–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤
//	—ç—Ç–æ–π –º–∞—Ç—Ä–∏—Ü—ã, –ª–µ–∂–∞—â–∏—Ö –Ω–∞ –ø—Ä—è–º–æ–π, –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ–π –ø—Ä—è–º–æ–π, —Å–æ–¥–µ—Ä–∂–∞—â–µ–π —ç–ª–µ–º–µ–Ω—Ç—ã
//	ùëé[ùëñ,ùëñ]. –ù–∞–π—Ç–∏ —Å—É–º–º—É –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –≤—Å–µ—Ö –ø—Å–µ–≤–¥–æ–¥–∏–∞–≥–æ–Ω–∞–ª–µ–π –¥–∞–Ω–Ω–æ–π
//	–º–∞—Ç—Ä–∏—Ü—ã. –ù–∞ —Ä–∏—Å—É–Ω–∫–µ –Ω–∏–∂–µ –≤—Å–µ –ø—Å–µ–≤–¥–æ–¥–∏–∞–≥–æ–Ω–∞–ª–∏ –≤—ã–¥–µ–ª–µ–Ω—ã —Ä–∞–∑–ª–∏—á–Ω—ã–º–∏
//	—Ü–≤–µ—Ç–∞–º–∏:
#ifdef TASK_7

/**
 * @brief –ü–æ–∏—Å–∫ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞ –¥–∏–∞–≥–æ–Ω–∞–ª–∏ –º–∞—Ç—Ä–∏—Ü—ã
 * @param m 		–º–∞—Ç—Ä–∏—Ü–∞
 * @param row_i –∏–Ω–¥–µ–∫—Å —Å—Ç—Ä–æ–∫–∏ –Ω–∞—á–∞–ª—å–Ω–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞ –¥–∏–∞–≥–æ–Ω–∞–ª–∏
 * @param col_i –∏–Ω–¥–µ–∫—Å —Å—Ç–æ–ª–±—Ü–∞ –Ω–∞—á–∞–ª—å–Ω–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞ –¥–∏–∞–≥–æ–Ω–∞–ª–∏
 * @return –∑–Ω–∞—á–µ–Ω–∏–µ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞ –¥–∏–∞–≥–æ–Ω–∞–ª–∏
 */
int FindMaxOnDiagonal(const Matrix m,
                      size_t row_i,
                      size_t col_i) {
  int max = m.data[row_i][col_i];
  while (col_i < m.n_cols && row_i < m.n_rows) {
    if (m.data[row_i][col_i] > max) {
      max = m.data[row_i][col_i];
    }
    row_i++;
    col_i++;
  }

  return max;
}

/**
 * @brief –í—ã—á–∏—Å–ª–µ–Ω–∏–µ —Å—É–º–º—ã –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –≤—Å–µ—Ö –ø—Å–µ–≤–¥–æ-–¥–∏–∞–≥–æ–Ω–∞–ª–µ–π –º–∞—Ç—Ä–∏—Ü—ã
 * @param m –º–∞—Ç—Ä–∏—Ü–∞
 * @return —Å—É–º–º–∞ –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –≤—Å–µ—Ö –ø—Å–µ–≤–¥–æ-–¥–∏–∞–≥–æ–Ω–∞–ª–µ–π –º–∞—Ç—Ä–∏—Ü—ã
 */
long long FindSumOfMaxesOfPseudoDiagonal(const Matrix m) {
  long long sum = 0;
  for (size_t row_shift = m.n_rows - 1; row_shift > 0; row_shift--) {
    sum += FindMaxOnDiagonal(m, row_shift, 0);
  }

  for (size_t col_shift = 1; col_shift < m.n_cols; col_shift++) {
    sum += FindMaxOnDiagonal(m, 0, col_shift);
  }

  return sum;
}

static void test_FindSumOfMaxesOfPseudoDiagonal_Square() {
  printf("[--------] Square\n");
  const size_t kInitialNRows = 3;
  const size_t kInitialNCols = 3;
  int initial_arr[] = {1, 2, 3,
                       4, 5, 6,
                       7, 8, 9};
  const int kExpected = 24;
  Matrix m = CreateMatrixFromArray(initial_arr, kInitialNRows,
                                   kInitialNCols);
  printf("[--------] n_rows = %zu, n_cols = %zu\n",
         kInitialNRows,
         kInitialNCols);
  printf("[RUN     ]\n");
  assert(FindSumOfMaxesOfPseudoDiagonal(m) == kExpected);

  FreeMemMatrix(&m);
  printf("[      OK]\n");
}

static void test_FindSumOfMaxesOfPseudoDiagonal_Wide() {
  printf("[--------] Wide\n");
  const size_t kInitialNRows = 3;
  const size_t kInitialNCols = 4;
  int initial_arr[] = {3, 2, 5, 4,
                       1, 3, 6, 3,
                       3, 2, 1, 2};
  const int kExpected = 20;
  Matrix m = CreateMatrixFromArray(initial_arr, kInitialNRows,
                                   kInitialNCols);
  printf("[--------] n_rows = %zu, n_cols = %zu\n",
         kInitialNRows,
         kInitialNCols);
  printf("[RUN     ]\n");
  assert(FindSumOfMaxesOfPseudoDiagonal(m) == kExpected);

  FreeMemMatrix(&m);
  printf("[      OK]\n");
}

static void test_FindSumOfMaxesOfPseudoDiagonal_Toll() {
  printf("[--------] Toll\n");
  const size_t kInitialNRows = 4;
  const size_t kInitialNCols = 3;
  int initial_arr[] = {3, 2, 5,
                       4, 1, 3,
                       6, 3, 3,
                       2, 1, 2};
  const int kExpected = 20;
  Matrix m = CreateMatrixFromArray(initial_arr, kInitialNRows,
                                   kInitialNCols);
  printf("[--------] n_rows = %zu, n_cols = %zu\n",
         kInitialNRows,
         kInitialNCols);
  printf("[RUN     ]\n");
  assert(FindSumOfMaxesOfPseudoDiagonal(m) == kExpected);

  FreeMemMatrix(&m);
  printf("[      OK]\n");
}

static void test_FindSumOfMaxesOfPseudoDiagonal() {
  printf("[========] %s()\n", __FUNCTION__);
  test_FindSumOfMaxesOfPseudoDiagonal_Square();
  test_FindSumOfMaxesOfPseudoDiagonal_Wide();
  test_FindSumOfMaxesOfPseudoDiagonal_Toll();
}

int main() {
  test_FindSumOfMaxesOfPseudoDiagonal();

  return 0;
}

#endif // TASK_7

//	–î–∞–Ω–∞ –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∞—è –º–∞—Ç—Ä–∏—Ü–∞, –≤—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã –∫–æ—Ç–æ—Ä–æ–π —Ä–∞–∑–ª–∏—á–Ω—ã. –ù–∞–π—Ç–∏ –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π
//	—ç–ª–µ–º–µ–Ω—Ç –º–∞—Ç—Ä–∏—Ü—ã –≤ –≤—ã–¥–µ–ª–µ–Ω–Ω–æ–π –æ–±–ª–∞—Å—Ç–∏:
#ifdef TASK_8

/**
 * @brief –ü–æ–∏—Å–∫ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –º–∞—Å—Å–∏–≤–∞
 *
 * @param arr		—É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ –Ω—É–ª–µ–≤–æ–π —ç–ª–µ–º–µ–Ω—Ç –º–∞—Å—Å–∏–≤–∞
 * @param size	–∫–æ–ª-–≤–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –º–∞—Å—Å–∏–≤–∞
 * @return	–º–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –º–∞—Å—Å–∏–≤–∞
 */
int GetMin(int* arr,
           const size_t size) {
  int min = arr[0];
  for (size_t i = 0; i < size; i++) {
    if (arr[i] < min) {
      min = arr[i];
    }
  }

  return min;
}

/**
 * @brief –ü–æ–∏—Å–∫ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞, –ª–µ–∂–∞—â–µ–≥–æ –≤ —Ç—Ä–µ—É–≥–æ–ª—å–Ω–æ–π –æ–±–ª–∞—Å—Ç–∏ –Ω–∞–¥
 * 				–º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–º —ç–ª–µ–º–µ–Ω—Ç–æ–º
 * @param m –º–∞—Ç—Ä–∏—Ü–∞
 * @return 	–∑–Ω–∞—á–µ–Ω–∏–µ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞, –ª–µ–∂–∞—â–µ–≥–æ –≤ —Ç—Ä–µ—É–≥–æ–ª—å–Ω–æ–π –æ–±–ª–∞—Å—Ç–∏ –Ω–∞–¥
 * 					–º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–º —ç–ª–µ–º–µ–Ω—Ç–æ–º
 */
int GetMinInMaxArea(const Matrix m) {
  Position max_p = GetMaxValuePos(m);
  int min = m.data[max_p.row_i][max_p.col_i];
  for (size_t row_i = max_p.row_i; row_i != -1; row_i--) {
    const size_t col_shift = max_p.row_i - row_i;
    const size_t begin_col_i = max(0, max_p.col_i - col_shift);
    const size_t end_col_i = min(m.n_cols - 1, max_p.col_i + col_shift);
    min = GetMin(m.data[row_i] + begin_col_i, end_col_i - begin_col_i + 1);
  }

  return min;
}

static void test_GetMinInMaxArea_FullArea() {
  printf("[--------] FullArea\n");
  const size_t kInitialNRows = 3;
  const size_t kInitialNCols = 4;
  int initial_arr[] = {10, 7, 5, 6,
                       3, 11, 8, 9,
                       4, 1, 12, 2};
  const int kExpected = 5;
  Matrix m = CreateMatrixFromArray(initial_arr, kInitialNRows,
                                   kInitialNCols);

  printf("[--------] n_rows_1 = %zu, n_cols_1 = %zu\n",
         kInitialNRows,
         kInitialNCols);
  printf("[RUN     ]\n");
  assert(GetMinInMaxArea(m) == kExpected);

  FreeMemMatrix(&m);
  printf("[      OK]\n");
}

static void test_GetMinInMaxArea_NotFullArea() {
  printf("[--------] NotFullArea\n");
  const size_t kInitialNRows = 3;
  const size_t kInitialNCols = 4;
  int initial_arr[] = {6, 8, 9, 2,
                       7, 12, 3, 4,
                       10, 11, 5, 1};
  const int kExpected = 6;
  Matrix m = CreateMatrixFromArray(initial_arr, kInitialNRows,
                                   kInitialNCols);

  printf("[--------] n_rows_1 = %zu, n_cols_1 = %zu\n",
         kInitialNRows,
         kInitialNCols);
  printf("[RUN     ]\n");
  assert(GetMinInMaxArea(m) == kExpected);

  FreeMemMatrix(&m);
  printf("[      OK]\n");
}

static void test_GetMinInMaxArea_OneEl() {
  printf("[--------] NotFullArea\n");
  const size_t kInitialNRows = 3;
  const size_t kInitialNCols = 4;
  int initial_arr[] = {6, 69, 9, 2,
                       7, 12, 3, 4,
                       10, 11, 5, 1};
  const int kExpected = 69;
  Matrix m = CreateMatrixFromArray(initial_arr, kInitialNRows,
                                   kInitialNCols);

  printf("[--------] n_rows_1 = %zu, n_cols_1 = %zu\n",
         kInitialNRows,
         kInitialNCols);
  printf("[RUN     ]\n");
  assert(GetMinInMaxArea(m) == kExpected);

  FreeMemMatrix(&m);
  printf("[      OK]\n");
}

static void test_GetMinInMaxArea() {
  printf("[========] %s()\n", __FUNCTION__);
  test_GetMinInMaxArea_NotFullArea();
  test_GetMinInMaxArea_OneEl();
  test_GetMinInMaxArea_OneEl();
}

int main() {
  test_GetMinInMaxArea();

  return 0;
}

#endif // TASK_8

//	–î–∞–Ω–æ ùëõ —Ç–æ—á–µ–∫ –≤ ùëö-–º–µ—Ä–Ω–æ–º –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ. –£–ø–æ—Ä—è–¥–æ—á–∏—Ç—å —Ç–æ—á–∫–∏ –ø–æ –Ω–µ—É–±—ã–≤–∞–Ω–∏—é –∏—Ö
//	—Ä–∞—Å—Å—Ç–æ—è–Ω–∏–π –¥–æ –Ω–∞—á–∞–ª–∞ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç.
#ifdef TASK_9

#include <math.h>

/**
 * @brief –í—ã—á–∏—Å–ª–µ–Ω–∏–µ —Å—É–º–º—ã –∫–≤–∞–¥—Ä–∞—Ç–æ–≤ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –º–∞—Å—Å–∏–≤–∞
 * @param arr 	—É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ –Ω—É–ª–µ–≤–æ–π —ç–ª–µ–º–µ–Ω—Ç –º–∞—Å—Å–∏–≤–∞
 * @param size 	–∫–æ–ª-–≤–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –º–∞—Å—Å–∏–≤–∞
 * @return —Å—É–º–º—É –∫–≤–∞–¥—Ä–∞—Ç–æ–≤ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –º–∞—Å—Å–∏–≤–∞
 */
long long GetSumOfSquares(int* arr,
                          const size_t size) {
  long long sum = 0;
  for (size_t i = 0; i < size; i++) {
    sum += arr[i] * arr[i];
  }

  return sum;
}

/**
 * @brief –í—ã—á–∏—Å–ª–µ–Ω–∏–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è –æ—Ç —Ç–æ—á–∫–∏, –∑–∞–¥–∞–Ω–Ω–æ–π –≤ n-–º–µ—Ä–Ω–æ–º –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ,
 * 				–¥–æ –Ω–∞—á–∞–ª–∞ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç
 * @param arr		—É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ –Ω—É–ª–µ–≤–æ–π —ç–ª–µ–º–µ–Ω—Ç –º–∞—Å—Å–∏–≤–∞
 * @param size	–∫–æ–ª-–≤–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –º–∞—Å—Å–∏–≤–∞
 * @return 	—Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –æ—Ç —Ç–æ—á–∫–∏, –∑–∞–¥–∞–Ω–Ω–æ–π –≤ n-–º–µ—Ä–Ω–æ–º –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ,
 * 					–¥–æ –Ω–∞—á–∞–ª–∞ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç
 */
double GetDistance(int* arr,
                   const size_t size) {
  return sqrt(GetSumOfSquares(arr, size));
}

/**
 * @brief –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –º–∞—Å—Å–∏–≤–∞ —Ç–æ—á–µ–∫, –∑–∞–¥–∞–Ω–Ω–æ–≥–æ —Å –ø–æ–º–æ—â—å—é –º–∞—Ç—Ä–∏—Ü—ã –≤ –ø–æ—Ä—è–¥–∫–µ
 * 				–Ω–µ—É–±—ã–≤–∞–Ω–∏—è —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è –æ—Ç –Ω–∞—á–∞–ª–∞ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç
 * @param m –º–∞—Ç—Ä–∏—Ü–∞
 */
void SortByDistance(Matrix m) {
  InsertionSortRowsMatrixByRowCriteriaF(m, GetDistance);
}

static void test_SortByDistance_Sorted() {
  printf("[--------] Sorted\n");
  const size_t kInitialNRows = 5;
  const size_t kInitialNCols = 4;
  int initial_arr[] = {1, 0, 0, 0,
                       2, 3, 1, 1,
                       5, 5, 5, 5,
                       0, 100, 0, 0,
                       99, 99, 99, 99};
  int expected_arr[] = {1, 0, 0, 0,
                        2, 3, 1, 1,
                        5, 5, 5, 5,
                        0, 100, 0, 0,
                        99, 99, 99, 99};
  Matrix m = CreateMatrixFromArray(initial_arr, kInitialNRows, kInitialNCols);
  Matrix expected_m = CreateMatrixFromArray(expected_arr, kInitialNRows,
                                            kInitialNCols);
  printf("[--------] n_rows = %zu, n_cols = %zu\n",
         kInitialNRows,
         kInitialNCols);
  printf("[RUN     ]\n");
  SortByDistance(m);
  assert(AreTwoMatricesEqual(m, expected_m));

  FreeMemMatrix(&m);
  FreeMemMatrix(&expected_m);
  printf("[      OK]\n");
}

static void test_SortByDistance_Unsorted() {
  printf("[--------] Unsorted\n");
  const size_t kInitialNRows = 5;
  const size_t kInitialNCols = 4;
  int initial_arr[] = {20, 21, 22, 23,
                       6, 7, 8, 9,
                       10, 11, 12, 13,
                       1, 2, 3, 4,
                       15, 16, 17, 19};
  int expected_arr[] = {1, 2, 3, 4,
                        6, 7, 8, 9,
                        10, 11, 12, 13,
                        15, 16, 17, 19,
                        20, 21, 22, 23};
  Matrix m = CreateMatrixFromArray(initial_arr, kInitialNRows, kInitialNCols);
  Matrix expected_m = CreateMatrixFromArray(expected_arr, kInitialNRows,
                                            kInitialNCols);
  printf("[--------] n_rows = %zu, n_cols = %zu\n",
         kInitialNRows,
         kInitialNCols);
  printf("[RUN     ]\n");
  SortByDistance(m);
  assert(AreTwoMatricesEqual(m, expected_m));

  FreeMemMatrix(&m);
  FreeMemMatrix(&expected_m);
  printf("[      OK]\n");
}

static void test_SortByDistance_OneEl() {
  printf("[--------] OneEl\n");
  const size_t kInitialNRows = 1;
  const size_t kInitialNCols = 1;
  int initial_arr[] = {34, 723, 132};
  int expected_arr[] = {34, 723, 132};
  Matrix m = CreateMatrixFromArray(initial_arr, kInitialNRows, kInitialNCols);
  Matrix expected_m = CreateMatrixFromArray(expected_arr, kInitialNRows,
                                            kInitialNCols);

  printf("[--------] n_rows = %zu, n_cols = %zu\n",
         kInitialNRows,
         kInitialNCols);
  printf("[RUN     ]\n");
  SortByDistance(m);
  assert(AreTwoMatricesEqual(m, expected_m));

  FreeMemMatrix(&m);
  FreeMemMatrix(&expected_m);
  printf("[      OK]\n");
}

static void test_SortByDistance() {
  printf("[========] %s()\n", __FUNCTION__);
  test_SortByDistance_Unsorted();
  test_SortByDistance_Sorted();
  test_SortByDistance_OneEl();
}

int main() {
  test_SortByDistance();

  return 0;
}

#endif // TASK_9

//  –û–ø—Ä–µ–¥–µ–ª–∏—Ç—å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–ª–∞—Å—Å–æ–≤ —ç–∫–≤–∏–≤–∞–ª–µ–Ω—Ç–Ω—ã—Ö —Å—Ç—Ä–æ–∫ –¥–∞–Ω–Ω–æ–π –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–æ–π
//	–º–∞—Ç—Ä–∏—Ü—ã. –°—Ç—Ä–æ–∫–∏ —Å—á–∏—Ç–∞—Ç—å —ç–∫–≤–∏–≤–∞–ª–µ–Ω—Ç–Ω—ã–º–∏, –µ—Å–ª–∏ —Ä–∞–≤–Ω—ã —Å—É–º–º—ã –∏—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤.
#ifdef TASK_10

#include <stdlib.h>

#define cmp(a, b)                                                            \
((a) > (b) ? -1 : ((a) < (b) ? 1 : 0))

/**
 * @brief –í—ã—á–∏—Å–ª–µ–Ω–∏–µ —Å—É–º–º—ã —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –º–∞—Å—Å–∏–≤–∞
 * @param arr		—É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ –Ω—É–ª–µ–≤–æ–π —ç–ª–µ–º–µ–Ω—Ç –º–∞—Å—Å–∏–≤–∞
 * @param size	–∫–æ–ª-–≤–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –≤ –º–∞—Å—Å–∏–≤–µ
 * @return	—Å—É–º–º—É —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –º–∞—Å—Å–∏–≤–∞
 */
int GetSum(int* arr,
           const size_t size) {
  int sum = 0;
  for (size_t i = 0; i < size; i++) {
    sum += arr[i];
  }

  return sum;
}

/**
 * @brief –∫–æ–º–ø–∞—Ä–∞—Ç–æ—Ä —Ü–µ–ª–æ—á–∏—Å–ª–µ–Ω–Ω—ã–π –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö —Ç–∏–ø–∞ long long
 * @param pa	—É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ –ø–µ—Ä–≤—É—é –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é
 * @param pb	—É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ –≤—Ç–æ—Ä—É—é –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é
 * @return	-1, –µ—Å–ª–∏ —á–∏—Å–ª–∞ —É–ø–æ—Ä—è–¥–æ—á–µ–Ω—ã –ø–æ —É–±—ã–≤–∞–Ω–∏—é,
 * 					1, –µ—Å–ª–∏ –ø–æ –≤–æ–∑—Ä–∞—Å—Ç–∞–Ω–∏—é,
 * 					0, –µ—Å–ª–∏ —á–∏—Å–ª–∞ —Ä–∞–≤–Ω—ã
 */
int cmp_long_long(const void* pa,
                  const void* pb) {
  return cmp(*(long long*) pa, *(long long*) pb);
}

/**
 * @brief –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –º–∞—Å—Å–∏–≤–∞ –∏ –ø–æ–¥—Å—á–µ—Ç –∫–æ–ª-–≤–∞ –≥—Ä—É–ø–ø —Ä–∞–∑–ª–∏—á–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤
 * 				–º–∞—Å—Å–∏–≤–∞
 * @param arr 	—É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ –Ω—É–ª–µ–≤–æ–π —ç–ª–µ–º–µ–Ω—Ç –º–∞—Å—Å–∏–≤–∞
 * @param size 	–∫–æ–ª-–≤–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –º–∞—Å—Å–∏–≤–∞
 * @return	–∫–æ–ª-–≤–æ –≥—Ä—É–ø–ø –Ω–µ—É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤
 */
size_t CountNUnique(long long* arr,
                    const size_t size) {
  if (size == 0) {
    return 0;
  }

  qsort(arr, size, sizeof(*arr), cmp_long_long);
  size_t n_unique_count = 1;
  for (size_t i = 0; i < size - 1; i++) {
    n_unique_count += arr[i] != arr[i + 1];
  }

  return n_unique_count;
}

/**
 * @brief –ü–æ–¥—Å—á–µ—Ç –∫–æ–ª-–≤–∞ –∫–ª–∞—Å—Å–æ–≤ —ç–∫–≤–∏–≤–∞–ª–µ–Ω—Ç–Ω—ã—Ö –ø–æ —Å—É–º–º–µ —Å—Ç—Ä–æ–∫
 * @param m –º–∞—Ç—Ä–∏—Ü–∞
 * @return –∫–æ–ª-–≤–æ –∫–ª–∞—Å—Å–æ–≤ —ç–∫–≤–∏–≤–∞–ª–µ–Ω—Ç–Ω—ã—Ö –ø–æ —Å—É–º–º–µ —Å—Ç—Ä–æ–∫
 */
size_t CountEqClassesByRowsSum(const Matrix m) {
  long long* rows_sums = (long long*) malloc(m.n_cols * sizeof(*rows_sums));
  for (size_t row_i = 0; row_i < m.n_rows; row_i++) {
    rows_sums[row_i] = GetSum(m.data[row_i], m.n_cols);
  }

  const size_t n_unique_count = CountNUnique(rows_sums, m.n_rows);
  free(rows_sums);

  return n_unique_count;
}

static void test_CountEqClassesByRowsSum_OneClass() {
  printf("[--------] OneClass\n");
  const size_t kInitialNRows = 5;
  const size_t kInitialNCols = 2;
  int initial_arr[] = {1, 9,
                       10, 0,
                       2, 8,
                       4, 6,
                       3, 7};
  const size_t kEqClassesCount = 1;
  Matrix m = CreateMatrixFromArray(initial_arr, kInitialNRows, kInitialNCols);

  printf("[--------] n_rows = %zu, n_cols = %zu\n",
         kInitialNRows,
         kInitialNCols);
  printf("[RUN     ]\n");
  assert(CountEqClassesByRowsSum(m) == kEqClassesCount);

  FreeMemMatrix(&m);
  printf("[      OK]\n");
}

static void test_CountEqClassesByRowsSum_ManyClasses() {
  printf("[--------] ManyClasses\n");
  const size_t kInitialNRows = 5;
  const size_t kInitialNCols = 2;
  int initial_arr[] = {7, 1,
                       2, 7,
                       5, 4,
                       4, 3,
                       1, 6,
                       8, 0};
  const size_t kEqClassesCount = 3;
  Matrix m = CreateMatrixFromArray(initial_arr, kInitialNRows, kInitialNCols);

  printf("[--------] n_rows = %zu, n_cols = %zu\n",
         kInitialNRows,
         kInitialNCols);
  printf("[RUN     ]\n");
  assert(CountEqClassesByRowsSum(m) == kEqClassesCount);

  FreeMemMatrix(&m);
  printf("[      OK]\n");
}

static void test_CountEqClassesByRowsSum() {
  printf("[========] %s()\n", __FUNCTION__);
  test_CountEqClassesByRowsSum_OneClass();
  test_CountEqClassesByRowsSum_ManyClasses();
}

int main() {
  test_CountEqClassesByRowsSum();

  return 0;
}

#endif // TASK_10

// 	–î–∞–Ω–∞ –º–∞—Ç—Ä–∏—Ü–∞. –û–ø—Ä–µ–¥–µ–ª–∏—Ç—å ùëò ‚Äì –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ "–æ—Å–æ–±—ã—Ö" —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –º–∞—Ç—Ä–∏—Ü—ã, —Å—á–∏—Ç–∞—è
//	—ç–ª–µ–º–µ–Ω—Ç "–æ—Å–æ–±—ã–º", –µ—Å–ª–∏ –æ–Ω –±–æ–ª—å—à–µ —Å—É–º–º—ã –æ—Å—Ç–∞–ª—å–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤ —Å–≤–æ–µ–≥–æ —Å—Ç–æ–ª–±—Ü–∞
#ifdef TASK_11

/**
 * @brief –ü–æ–¥—Å—á–µ—Ç –∫–æ–ª-–≤–∞ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –º–∞—Ç—Ä–∏—Ü—ã, –±–æ–ª—å—à–∏—Ö —Å—É–º–º—ã –æ—Å—Ç–∞–ª—å–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤
 * 				—Å–≤–æ–µ–≥–æ —Å—Ç–æ–ª–±—Ü–∞
 * @param m –º–∞—Ç—Ä–∏—Ü–∞
 * @return 	–∫–æ–ª-–≤–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –º–∞—Ç—Ä–∏—Ü—ã, –±–æ–ª—å—à–∏—Ö —Å—É–º–º—ã –æ—Å—Ç–∞–ª—å–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤
 * 					—Å–≤–æ–µ–≥–æ —Å—Ç–æ–ª–±—Ü–∞
 */
size_t GetNSpecialEl(const Matrix m) {
  size_t special_el_count = 0;
  for (size_t col_i = 0; col_i < m.n_cols; col_i++) {
    long long cur_sum = 0;
    int cur_max = m.data[0][col_i];
    for (size_t row_i = 0; row_i < m.n_rows; row_i++) {
      cur_sum += m.data[row_i][col_i];
      if (m.data[row_i][col_i] > cur_max) {
        cur_max = m.data[row_i][col_i];
      }
    }
    special_el_count += cur_max > cur_sum - cur_max;
  }

  return special_el_count;
}

static void test_GetNSpecialEl_SomeEl() {
  printf("[--------] SomeEl\n");
  const size_t kInitialNRows = 3;
  const size_t kInitialNCols = 4;
  int initial_arr[] = {3, 5, 5, 4,
                       2, 3, 6, 7,
                       12, 2, 1, 2};
  const size_t kSpecialCount = 2;
  Matrix m = CreateMatrixFromArray(initial_arr, kInitialNRows, kInitialNCols);

  printf("[--------] n_rows = %zu, n_cols = %zu\n",
         kInitialNRows,
         kInitialNCols);
  printf("[RUN     ]\n");
  assert(GetNSpecialEl(m) == kSpecialCount);

  FreeMemMatrix(&m);
  printf("[      OK]\n");
}

static void test_GetNSpecialEl_None() {
  printf("[--------] None\n");
  const size_t kInitialNRows = 3;
  const size_t kInitialNCols = 4;
  int initial_arr[] = {3, 5, 5, 4,
                       2, 3, 6, 6,
                       5, 2, 1, 2};
  const size_t kSpecialCount = 0;
  Matrix m = CreateMatrixFromArray(initial_arr, kInitialNRows, kInitialNCols);

  printf("[--------] n_rows = %zu, n_cols = %zu\n",
         kInitialNRows,
         kInitialNCols);
  printf("[RUN     ]\n");
  assert(GetNSpecialEl(m) == kSpecialCount);

  FreeMemMatrix(&m);
  printf("[      OK]\n");
}

static void test_GetNSpecialEl() {
  printf("[========] %s()\n", __FUNCTION__);
  test_GetNSpecialEl_SomeEl();
  test_GetNSpecialEl_None();
}

int main() {
  test_GetNSpecialEl();

  return 0;
}

#endif // TASK_11

// 	–î–∞–Ω–∞ –∫–≤–∞–¥—Ä–∞—Ç–Ω–∞—è –º–∞—Ç—Ä–∏—Ü–∞. –ó–∞–º–µ–Ω–∏—Ç—å –ø—Ä–µ–¥–ø–æ—Å–ª–µ–¥–Ω—é—é —Å—Ç—Ä–æ–∫—É –º–∞—Ç—Ä–∏—Ü—ã –ø–µ—Ä–≤—ã–º
//	–∏–∑ —Å—Ç–æ–ª–±—Ü–æ–≤, –≤ –∫–æ—Ç–æ—Ä–æ–º –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç –º–∞—Ç—Ä–∏—Ü—ã.
#ifdef TASK_12

/**
 * @brief –ü–æ–∏—Å–∫ –ø–æ–∑–∏—Ü–∏–∏ —Å–∞–º–æ–≥–æ –ª–µ–≤–æ–≥–æ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞ –º–∞—Ç—Ä–∏—Ü—ã
 * @param m –º–∞—Ç—Ä–∏—Ü–∞
 * @return –ø–æ–∑–∏—Ü–∏—é —Å–∞–º–æ–≥–æ –ª–µ–≤–æ–≥–æ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞ –º–∞—Ç—Ä–∏—Ü—ã
 */
Position GetLeftMin(const Matrix m) {
  int min = m.data[0][0];
  size_t min_row_i = 0;
  size_t min_col_i = 0;
  for (size_t col_i = 0; col_i < m.n_cols; col_i++) {
    for (size_t row_i = 0; row_i < m.n_rows; row_i++) {
      if (m.data[row_i][col_i] < min) {
        min = m.data[row_i][col_i];
        min_row_i = row_i;
        min_col_i = col_i;
      }
    }
  }

  return (Position) {min_row_i, min_col_i};
}

/**
 * @brief –ó–∞–º–µ–Ω–∞ –∑–∞–¥–∞–Ω–Ω–æ–π —Å—Ç—Ä–æ–∫–∏ –∫–≤–∞–¥—Ä–∞—Ç–Ω–æ–π –º–∞—Ç—Ä–∏—Ü—ã –Ω–∞ —Å—Ç–æ–ª–±–µ—Ü, —Å–æ–¥–µ—Ä–∂–∞—â–∏–π
 * 				—Å–∞–º—ã–π –ª–µ–≤—ã–π –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç
 * @param m						–º–∞—Ç—Ä–∏—Ü–∞
 * @param swap_row_i	–∏–Ω–¥–µ–∫—Å —Å—Ç—Ä–æ–∫–∏
 */
void SwapPenultimateRow(Matrix m,
                        const size_t swap_row_i) {
  const Position l_min_col_p = GetLeftMin(m);
  const int t = m.data[swap_row_i][l_min_col_p.col_i];
  for (size_t col_i = 0, row_i = 0; col_i < m.n_cols; col_i++, row_i++) {
    if (row_i == swap_row_i) {
      m.data[swap_row_i][col_i] = t;
    } else {
      m.data[swap_row_i][col_i] = m.data[row_i][l_min_col_p.col_i];
    }
  }
}

static void test_SwapPenultimateRow_First() {
  printf("[--------] First\n");
  const size_t kInitialNRows = 3;
  const size_t kInitialNCols = 3;
  const size_t kInitialSwapRowI = 1;
  int initial_arr[] = {1, 2, 3,
                       4, 5, 6,
                       7, 8, 1};
  int expected_arr[] = {1, 2, 3,
                        1, 4, 7,
                        7, 8, 1};
  Matrix m = CreateMatrixFromArray(initial_arr, kInitialNRows,
                                   kInitialNCols);
  Matrix expected_m = CreateMatrixFromArray(expected_arr, kInitialNRows,
                                            kInitialNCols);
  printf("[--------] n_rows = %zu, n_cols = %zu\n",
         kInitialNRows,
         kInitialNCols);
  printf("[RUN     ]\n");
  SwapPenultimateRow(m, kInitialSwapRowI);
  assert(AreTwoMatricesEqual(m, expected_m));

  FreeMemMatrix(&m);
  FreeMemMatrix(&expected_m);
  printf("[      OK]\n");
}

static void test_SwapPenultimateRow_NotFirst() {
  printf("[--------] NotFirst\n");
  const size_t kInitialNRows = 3;
  const size_t kInitialNCols = 3;
  const size_t kInitialSwapColI = 1;
  int initial_arr[] = {1, 2, -3,
                       4, 5, 6,
                       7, 8, 9};
  int expected_arr[] = {1, 2, -3,
                        -3, 6, 9,
                        7, 8, 9};
  Matrix m = CreateMatrixFromArray(initial_arr, kInitialNRows,
                                   kInitialNCols);
  Matrix expected_m = CreateMatrixFromArray(expected_arr, kInitialNRows,
                                            kInitialNCols);
  printf("[--------] n_rows = %zu, n_cols = %zu\n",
         kInitialNRows,
         kInitialNCols);
  printf("[RUN     ]\n");
  SwapPenultimateRow(m, kInitialSwapColI);
  assert(AreTwoMatricesEqual(m, expected_m));

  FreeMemMatrix(&m);
  FreeMemMatrix(&expected_m);
  printf("[      OK]\n");
}

static void test_SwapPenultimateRow() {
  printf("[========] %s()\n", __FUNCTION__);
  test_SwapPenultimateRow_First();
  test_SwapPenultimateRow_NotFirst();
}

int main() {
  test_SwapPenultimateRow();

  return 0;
}

#endif // TASK_12

// 	–î–∞–Ω –º–∞—Å—Å–∏–≤ –º–∞—Ç—Ä–∏—Ü –æ–¥–Ω–æ–≥–æ —Ä–∞–∑–º–µ—Ä–∞. –û–ø—Ä–µ–¥–µ–ª–∏—Ç—å —á–∏—Å–ª–æ –º–∞—Ç—Ä–∏—Ü, —Å—Ç—Ä–æ–∫–∏ –∫–æ—Ç–æ—Ä—ã—Ö
// 	—É–ø–æ—Ä—è–¥–æ—á–µ–Ω—ã –ø–æ –Ω–µ—É–±—ã–≤–∞–Ω–∏—é —ç–ª–µ–º–µ–Ω—Ç–æ–≤
#ifdef TASK_13

/**
 * @brief –ü—Ä–æ–≤–µ—Ä–∫–∞, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –º–∞—Å—Å–∏–≤ –Ω–µ—É–±—ã–≤–∞—é—â–µ–π –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å—é
 *
 * @param arr		—É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ –Ω—É–ª–µ–≤–æ–π —ç–ª–µ–º–µ–Ω—Ç –º–∞—Å—Å–∏–≤–∞
 * @param size	–∫–æ–ª-–≤–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –≤ –º–∞—Å—Å–∏–≤–µ
 * @return	'true', –µ—Å–ª–∏ –º–∞—Å—Å–∏–≤ —É–ø–æ—Ä—è–¥–æ—á–µ–Ω –ø–æ –Ω–µ—É–±—ã–≤–∞–Ω–∏—é,
 * 					'false' –≤ –ø—Ä–æ—Ç–∏–≤–Ω–æ–º —Å–ª—É—á–∞–µ
 */
bool IsNonDecreasingSorted(int* arr,
                           const size_t size) {
  for (size_t i = 1; i < size; i++) {
    if (arr[i] < arr[i - 1]) {
      return false;
    }
  }

  return true;
}

/**
 * @brief –ü—Ä–æ–≤–µ—Ä–∫–∞, —á—Ç–æ –≤—Å–µ —Å—Ç—Ä–æ–∫–∏ –º–∞—Ç—Ä–∏—Ü—ã —É–ø–æ—Ä—è–¥–æ—á–µ–Ω—ã –ø–æ –Ω–µ—É–±—ã–≤–∞–Ω–∏—é
 *
 * @param m	–º–∞—Ç—Ä–∏—Ü–∞
 * @return	'true', —Å–µ —Å—Ç—Ä–æ–∫–∏ –º–∞—Ç—Ä–∏—Ü—ã —É–ø–æ—Ä—è–¥–æ—á–µ–Ω—ã –ø–æ –Ω–µ—É–±—ã–≤–∞–Ω–∏—é,
 * 					'false' –≤ –ø—Ä–æ—Ç–∏–≤–Ω–æ–º —Å–ª—É—á–∞–µ
 */
bool HasAllNonDecreasingRows(const Matrix m) {
  for (size_t row_i = 0; row_i < m.n_rows; row_i++) {
    if (!IsNonDecreasingSorted(m.data[row_i], m.n_cols)) {
      return false;
    }
  }

  return true;
}

/**
 * @brief –ü–æ–¥—Å—á–µ—Ç –º–∞—Ç—Ä–∏—Ü, —Å–æ–¥–µ—Ä–∂–∞—â–∏—Ö –≤—Å–µ —Å—Ç—Ä–æ–∫–∏, —É–ø–æ—Ä—è–¥–æ—á–µ–Ω–Ω—ã–µ –ø–æ –Ω–µ—É–±—ã–≤–∞–Ω–∏—é
 *
 * @param ms
 * @param n_matrices
 * @return
 */
size_t CountNonDescendingRowsMatrices(Matrix* ms,
                                      const size_t n_matrices) {
  size_t non_descending_row_ms_count = 0;
  for (size_t matrix_i = 0; matrix_i < n_matrices; matrix_i++) {
    non_descending_row_ms_count += HasAllNonDecreasingRows(ms[matrix_i]);
  }

  return non_descending_row_ms_count;
}

static void test_CountNonDescendingRowsMatrices() {
  printf("[========] %s()\n", __FUNCTION__);
  const size_t kInitialNMatrices = 4;
  const size_t kInitialNRows = 2;
  const size_t kInitialNCols = 2;
  int initial_arr[] = {7, 1,
                       1, 1,

                       1, 6,
                       2, 2,

                       5, 4,
                       2, 3,

                       1, 3,
                       7, 9};
  const size_t kExpected = 2;
  Matrix* ms = CreateArrayOfMatrixFromArray(initial_arr,
                                            kInitialNMatrices,
                                            kInitialNRows,
                                            kInitialNCols);

  printf("[--------] n_matrices = %zu,  n_rows = %zu, n_cols = %zu\n",
         kInitialNMatrices,
         kInitialNRows,
         kInitialNCols);
  printf("[RUN     ]\n");
  assert(CountNonDescendingRowsMatrices(ms, kInitialNMatrices) == kExpected);

  FreeMemMatrices(ms, kInitialNMatrices);
  printf("[      OK]\n");
}

int main() {
  test_CountNonDescendingRowsMatrices();

  return 0;
}

#endif // TASK_13

//	–î–∞–Ω –º–∞—Å—Å–∏–≤ —Ü–µ–ª–æ—á–∏—Å–ª–µ–Ω–Ω—ã—Ö –º–∞—Ç—Ä–∏—Ü. –í—ã–≤–µ—Å—Ç–∏ –º–∞—Ç—Ä–∏—Ü—ã, –∏–º–µ—é—â–∏–µ –Ω–∞–∏–±–æ–ª—å—à–µ–µ
//	—á–∏—Å–ª–æ –Ω—É–ª–µ–≤—ã—Ö —Å—Ç—Ä–æ–∫
#ifdef TASK_14

/**
 * @brief –ü–æ–¥—Å—á–µ—Ç –∫–æ–ª-–≤–∞ –≤—Ö–æ–∂–¥–µ–Ω–∏–π –∏—Å–∫–æ–º–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è –≤ –º–∞—Å—Å–∏–≤
 * @param arr 	—É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ –Ω—É–ª–µ–≤–æ–π —ç–ª–µ–º–µ–Ω—Ç –º–∞—Å—Å–∏–≤–∞
 * @param size 	–∫–æ–ª-–≤–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –º–∞—Å—Å–∏–≤–∞
 * @param val 	–∏—Å–∫–æ–º–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
 * @return –∫–æ–ª-–≤–æ –≤—Ö–æ–∂–¥–µ–Ω–∏–π –∏—Å–∫–æ–º–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è –≤ –º–∞—Å—Å–∏–≤
 */
size_t CountValues(int* arr,
                   const size_t size,
                   const size_t val) {
  size_t val_count = 0;
  for (size_t i = 0; i < size; i++) {
    val_count += arr[i] == val;
  }

  return val_count;
}

/**
 * @brief –ü–æ–¥—Å—á–µ—Ç –Ω—É–ª–µ–≤—ã—Ö —Å—Ç—Ä–æ–∫ –º–∞—Ç—Ä–∏—Ü—ã
 * @param m –º–∞—Ç—Ä–∏—Ü–∞
 * @return –∫–æ–ª-–≤–æ –Ω—É–ª–µ–≤—ã—Ö —Å—Ç—Ä–æ–∫ –º–∞—Ç—Ä–∏—Ü—ã
 */
size_t CountZeroRows(const Matrix m) {
  size_t zero_rows_count = 0;
  for (size_t row_i = 0; row_i < m.n_rows; row_i++) {
    zero_rows_count += CountValues(m.data[row_i], m.n_cols, 0) == m.n_cols;
  }

  return zero_rows_count;
}

static void test_CountZeroRows_Zero() {
  printf("[--------] Zero\n");
  const size_t kInitialNRows = 5;
  const size_t kInitialNCols = 2;
  int initial_arr[] = {1, 0,
                       4, 6,
                       0, 7,
                       9, 8,
                       11, 0};
  const size_t kExpected = 0;
  Matrix m = CreateMatrixFromArray(initial_arr,
                                   kInitialNRows,
                                   kInitialNCols);

  printf("[--------] n_rows = %zu, n_cols = %zu\n",

         kInitialNRows,
         kInitialNCols);
  printf("[RUN     ]\n");
  assert(CountZeroRows(m) == kExpected);

  FreeMemMatrix(&m);
  printf("[      OK]\n");
}

static void test_CountZeroRows_NotZero() {
  printf("[--------] Zero\n");
  const size_t kInitialNRows = 5;
  const size_t kInitialNCols = 2;
  int initial_arr[] = {0, 0,
                       4, 0,
                       0, 7,
                       9, 8,
                       0, 0};
  const size_t kExpected = 2;
  Matrix m = CreateMatrixFromArray(initial_arr,
                                   kInitialNRows,
                                   kInitialNCols);

  printf("[--------] n_rows = %zu, n_cols = %zu\n",

         kInitialNRows,
         kInitialNCols);
  printf("[RUN     ]\n");
  assert(CountZeroRows(m) == kExpected);

  FreeMemMatrix(&m);
  printf("[      OK]\n");
}

static void test_CountZeroRows() {
  printf("[========] %s()\n", __FUNCTION__);
  test_CountZeroRows_NotZero();
  test_CountZeroRows_Zero();
}

/**
 * @brief –ü–æ–∏—Å–∫ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –º–∞—Å—Å–∏–≤–∞
 *
 * @param arr		—É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ –Ω—É–ª–µ–≤–æ–π —ç–ª–µ–º–µ–Ω—Ç –º–∞—Å—Å–∏–≤–∞
 * @param size	–∫–æ–ª-–≤–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –º–∞—Å—Å–∏–≤–∞
 * @return	–º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –º–∞—Å—Å–∏–≤–∞
 */
size_t GetMax(size_t* arr,
              const size_t size) {
  size_t max = arr[0];
  for (size_t i = 0; i < size; i++) {
    if (arr[i] > max) {
      max = arr[i];
    }
  }

  return max;
}

void PrintMatrixWithMaxZeroRows(Matrix* ms,
                                const size_t n_matrices) {
  size_t* ms_zero_rows_counts = (size_t*) malloc(n_matrices *
                                                 sizeof(*ms_zero_rows_counts));
  for (size_t matrix_i = 0; matrix_i < n_matrices; matrix_i++) {
    ms_zero_rows_counts[matrix_i] = CountZeroRows(ms[matrix_i]);
  }
  size_t max_m_zero_rows = GetMax(ms_zero_rows_counts, n_matrices);
  for (size_t matrix_i = 0; matrix_i < n_matrices; matrix_i++) {
    if (ms_zero_rows_counts[matrix_i] == max_m_zero_rows) {
      OutputMatrix(ms[matrix_i]);
    }
  }
}

int main() {
  test_CountZeroRows();

  size_t n_matrices, n_rows, n_cols;
  scanf("%zu %zu %zu", &n_matrices, &n_rows, &n_cols);
  Matrix* ms = GetMemArrayOfMatrices(n_matrices, n_rows, n_cols);
  InputMatrices(ms, n_matrices);
  PrintMatrixWithMaxZeroRows(ms, n_matrices);

  return 0;
}

#endif // TASK_14

//  –î–∞–Ω –º–∞—Å—Å–∏–≤ –≤–µ—â–µ—Å—Ç–≤–µ–Ω–Ω—ã—Ö –∫–≤–∞–¥—Ä–∞—Ç–Ω—ã—Ö –º–∞—Ç—Ä–∏—Ü. –í—ã–≤–µ—Å—Ç–∏ –º–∞—Ç—Ä–∏—Ü—ã —Å –Ω–∞–∏–º–µ–Ω—å—à–µ–π
//	–Ω–æ—Ä–º–æ–π. –í –∫–∞—á–µ—Å—Ç–≤–µ –Ω–æ—Ä–º—ã –º–∞—Ç—Ä–∏—Ü—ã –≤–∑—è—Ç—å –º–∞–∫—Å–∏–º—É–º –∞–±—Å–æ–ª—é—Ç–Ω—ã—Ö –≤–µ–ª–∏—á–∏–Ω –µ–µ
//	—ç–ª–µ–º–µ–Ω—Ç–æ–≤
#ifdef TASK_15

/**
 * @brief –ü–æ–∏—Å–∫ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–≥–æ –∞–±—Å–æ–ª—é—Ç–Ω–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –º–∞—Å—Å–∏–≤–∞
 *
 * @param arr		—É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ –Ω—É–ª–µ–≤–æ–π —ç–ª–µ–º–µ–Ω—Ç –º–∞—Å—Å–∏–≤–∞
 * @param size	–∫–æ–ª-–≤–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –º–∞—Å—Å–∏–≤–∞
 * @return	–º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∞–±—Å–æ–ª—é—Ç–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –º–∞—Å—Å–∏–≤–∞
 */
int GetMatrixAbsMax(const Matrix m) {
  int max = abs(m.data[0][0]);
  for (size_t row_i = 0; row_i < m.n_rows; row_i++) {
    for (size_t col_i = 0; col_i < m.n_cols; col_i++) {
      if (abs(m.data[row_i][col_i]) > max) {
        max = abs(m.data[row_i][col_i]);
      }
    }
  }

  return max;
}

/**
 * @brief –ü–æ–∏—Å–∫ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –º–∞—Å—Å–∏–≤–∞
 *
 * @param arr		—É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ –Ω—É–ª–µ–≤–æ–π —ç–ª–µ–º–µ–Ω—Ç –º–∞—Å—Å–∏–≤–∞
 * @param size	–∫–æ–ª-–≤–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –º–∞—Å—Å–∏–≤–∞
 * @return	–º–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –º–∞—Å—Å–∏–≤–∞
 */
int GetMin(int* arr,
           const size_t size) {
  int min = arr[0];
  for (size_t i = 0; i < size; i++) {
    if (arr[i] < min) {
      min = arr[i];
    }
  }

  return min;
}

void PrintMatrixWithMinNorms(Matrix* ms,
                             const size_t n_matrices) {
  int* ms_norms = (int*) malloc(n_matrices *
                                sizeof(*ms_norms));
  for (size_t matrix_i = 0; matrix_i < n_matrices; matrix_i++) {
    ms_norms[matrix_i] = GetMatrixAbsMax(ms[matrix_i]);
  }
  size_t min_m_norm = GetMin(ms_norms, n_matrices);
  for (size_t matrix_i = 0; matrix_i < n_matrices; matrix_i++) {
    if (ms_norms[matrix_i] == min_m_norm) {
      OutputMatrix(ms[matrix_i]);
    }
  }
}

int main() {
  size_t n_matrices, n_rows, n_cols;
  scanf("%zu %zu %zu", &n_matrices, &n_rows, &n_cols);
  Matrix* ms = GetMemArrayOfMatrices(n_matrices, n_rows, n_cols);
  InputMatrices(ms, n_matrices);
  PrintMatrixWithMinNorms(ms, n_matrices);

  return 0;
}

#endif // TASK_15

//	*–î–∞–Ω–∞ –º–∞—Ç—Ä–∏—Ü–∞. –û–ø—Ä–µ–¥–µ–ª–∏—Ç—å ùëò ‚Äì –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ "–æ—Å–æ–±—ã—Ö" —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –¥–∞–Ω–Ω–æ–π –º–∞—Ç—Ä–∏—Ü—ã,
//	—Å—á–∏—Ç–∞—è —ç–ª–µ–º–µ–Ω—Ç "–æ—Å–æ–±—ã–º" –µ—Å–ª–∏ –≤ —Å—Ç—Ä–æ–∫–µ —Å–ª–µ–≤–∞ –æ—Ç –Ω–µ–≥–æ –Ω–∞—Ö–æ–¥—è—Ç—Å—è –º–µ–Ω—å—à–∏–µ
//	—ç–ª–µ–º–µ–Ω—Ç—ã, –∞ —Å–ø—Ä–∞–≤–∞ ‚Äì –±–æ–ª—å—à–∏–µ
#ifdef TASK_16

/**
 * @brief –ü–æ–∏—Å–∫ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –º–∞—Å—Å–∏–≤–∞
 *
 * @param arr		—É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ –Ω—É–ª–µ–≤–æ–π —ç–ª–µ–º–µ–Ω—Ç –º–∞—Å—Å–∏–≤–∞
 * @param size	–∫–æ–ª-–≤–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –º–∞—Å—Å–∏–≤–∞
 * @return	–º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –º–∞—Å—Å–∏–≤–∞
 */
int GetMax(int* arr,
           const size_t size) {
  int max = arr[0];
  for (size_t i = 0; i < size; i++) {
    if (arr[i] > max) {
      max = arr[i];
    }
  }

  return max;
}

/**
 * @brief –ü–æ–∏—Å–∫ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –º–∞—Å—Å–∏–≤–∞
 *
 * @param arr		—É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ –Ω—É–ª–µ–≤–æ–π —ç–ª–µ–º–µ–Ω—Ç –º–∞—Å—Å–∏–≤–∞
 * @param size	–∫–æ–ª-–≤–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –º–∞—Å—Å–∏–≤–∞
 * @return	–º–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –º–∞—Å—Å–∏–≤–∞
 */
int GetMin(int* arr,
           const size_t size) {
  int min = arr[0];
  for (size_t i = 0; i < size; i++) {
    if (arr[i] < min) {
      min = arr[i];
    }
  }

  return min;
}

size_t GetNSpecialEl2(const Matrix m) {
  size_t specials_count = 0;
  for (size_t row_i = 0; row_i < m.n_rows; row_i++) {
    for (size_t col_i = 0; col_i < m.n_cols; col_i++) {
      bool l_cond = col_i == 0 ||
                    GetMax(m.data[row_i], col_i) < m.data[row_i][col_i];
      bool r_cond = col_i == m.n_cols - 1 ||
                    GetMin(m.data[row_i] + col_i + 1, m.n_cols - col_i - 1) >
                    m.data[row_i][col_i];
      specials_count += l_cond && r_cond;
    }
  }

  return specials_count;
}

static void test_GetNSpecialEl2_SomeEl() {
  printf("[--------] SomeEl\n");
  const size_t kInitialNRows = 3;
  const size_t kInitialNCols = 5;
  int initial_arr[] = {2, 3, 5, 5, 4,
                       6, 2, 3, 8, 12,
                       12, 12, 2, 1, 2};
  const size_t kExpected = 4;
  Matrix m = CreateMatrixFromArray(initial_arr, kInitialNRows, kInitialNCols);

  printf("[--------] n_rows = %zu, n_cols = %zu\n",
         kInitialNRows,
         kInitialNCols);
  printf("[RUN     ]\n");
  assert(GetNSpecialEl2(m) == kExpected);

  FreeMemMatrix(&m);
  printf("[      OK]\n");
}

static void test_GetNSpecialEl2_None() {
  printf("[--------] SomeEl\n");
  const size_t kInitialNRows = 3;
  const size_t kInitialNCols = 5;
  int initial_arr[] = {2, 1, 5, 5, 4,
                       6, 2, 3, 8, 6,
                       12, 12, 2, 1, 2};
  const size_t kExpected = 0;
  Matrix m = CreateMatrixFromArray(initial_arr, kInitialNRows, kInitialNCols);

  printf("[--------] n_rows = %zu, n_cols = %zu\n",
         kInitialNRows,
         kInitialNCols);
  printf("[RUN     ]\n");
  assert(GetNSpecialEl2(m) == kExpected);

  FreeMemMatrix(&m);
  printf("[      OK]\n");
}

static void test_GetNSpecialEl2() {
  printf("[========] %s()\n", __FUNCTION__);
  test_GetNSpecialEl2_SomeEl();
  test_GetNSpecialEl2_None();
}

int main() {
  test_GetNSpecialEl2();

  return 0;
}

#endif // TASK_16

//  *–ö–∞–∂–¥–∞—è —Å—Ç—Ä–æ–∫–∞ –¥–∞–Ω–Ω–æ–π –º–∞—Ç—Ä–∏—Ü—ã –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç —Å–æ–±–æ–π –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –≤–µ–∫—Ç–æ—Ä–∞ –≤
//  –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ. –û–ø—Ä–µ–¥–µ–ª–∏—Ç—å, –∫–∞–∫–æ–π –∏–∑ —ç—Ç–∏—Ö –≤–µ–∫—Ç–æ—Ä–æ–≤ –æ–±—Ä–∞–∑—É–µ—Ç –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —É–≥–æ–ª
//  —Å –¥–∞–Ω–Ω—ã–º –≤–µ–∫—Ç–æ—Ä–æ–º ùë£.
#ifdef TASK_17

#define THROW_EX(EXIT_CODE, ...) \
  fprintf(stderr, __VA_ARGS__);  \
  exit(EXIT_CODE)

#include <math.h>

long long GetScalarProduct(int* v_1,
                           int* v_2,
                           const size_t n) {
  long long scalar_prod = 0;
  for (size_t i = 0; i < n; i++) {
    scalar_prod += v_1[i] * v_2[i];
  }

  return scalar_prod;
}

/**
 * @brief –í—ã—á–∏—Å–ª–µ–Ω–∏–µ —Å—É–º–º—ã –∫–≤–∞–¥—Ä–∞—Ç–æ–≤ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –º–∞—Å—Å–∏–≤–∞
 * @param arr 	—É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ –Ω—É–ª–µ–≤–æ–π —ç–ª–µ–º–µ–Ω—Ç –º–∞—Å—Å–∏–≤–∞
 * @param size 	–∫–æ–ª-–≤–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –º–∞—Å—Å–∏–≤–∞
 * @return —Å—É–º–º—É –∫–≤–∞–¥—Ä–∞—Ç–æ–≤ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –º–∞—Å—Å–∏–≤–∞
 */
long long GetSumOfSquares(int* arr,
                          const size_t size) {
  long long sum = 0;
  for (size_t i = 0; i < size; i++) {
    sum += arr[i] * arr[i];
  }

  return sum;
}

/**
 * @brief –í—ã—á–∏—Å–ª–µ–Ω–∏–µ –¥–ª–∏–Ω—ã –≤–µ–∫—Ç–æ—Ä–∞, –∑–∞–¥–∞–Ω–Ω–æ–≥–æ –≤ n-–º–µ—Ä–Ω–æ–º –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ
 *
 * @param v		—É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ –Ω—É–ª–µ–≤–æ–π —ç–ª–µ–º–µ–Ω—Ç –º–∞—Å—Å–∏–≤–∞
 * @param size	–∫–æ–ª-–≤–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –º–∞—Å—Å–∏–≤–∞
 * @return 	–¥–ª–∏–Ω—É –≤–µ–∫—Ç–æ—Ä–∞, –∑–∞–¥–∞–Ω–Ω–æ–≥–æ –≤ n-–º–µ—Ä–Ω–æ–º –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ
 */
double GetVectorLength(int* v,
                       const size_t size) {
  return sqrt(GetSumOfSquares(v, size));
}

double GetCosine(int* v_1,
                 int* v_2,
                 const size_t n) {
  const double v_len_1 = GetVectorLength(v_1, n);
  const double v_len_2 = GetVectorLength(v_2, n);
  if (v_len_1 == 0 || v_len_2 == 0) {
    THROW_EX(69, "Dividing by zero\n");
  }
  return GetScalarProduct(v_1, v_2, n) / v_len_1 / v_len_2;
}

size_t GetVectorIndexWithMaxAngle(const Matrix m,
                                  int* v) {
  size_t min_angle_i = 0;
  double min_cos = GetCosine(m.data[0], v, m.n_cols);
  for (size_t row_i = 0; row_i < m.n_rows; row_i++) {
    const double cur_cos = GetCosine(m.data[row_i], v, m.n_cols);
    if (cur_cos < min_cos) {
      min_cos = cur_cos;
      min_angle_i = row_i;
    }
  }

  return min_angle_i;
}

static void test_GetVectorIndexWithMaxAngle_Unique() {
  printf("[--------] Unique\n");
  const size_t kInitialNRows = 3;
  const size_t kInitialNCols = 3;
  int initial_arr[] = {0, 1, 0,
                       -1, -1, -1,
                       5, 5, 5};

  int v[] = {1, 1, 1};
  const size_t kExpected = 1;
  Matrix m = CreateMatrixFromArray(initial_arr, kInitialNRows,
                                   kInitialNCols);
  printf("[--------] n_rows = %zu, n_cols = %zu\n",
         kInitialNRows,
         kInitialNCols);
  printf("[RUN     ]\n");
  assert(GetVectorIndexWithMaxAngle(m, v) == kExpected);

  FreeMemMatrix(&m);
  printf("[      OK]\n");
}

static void test_GetVectorIndexWithMaxAngle_NotUnique() {
  printf("[--------] NotUnique\n");
  const size_t kInitialNRows = 3;
  const size_t kInitialNCols = 3;
  int initial_arr[] = {-7, -7, 0,
                       -1, -1, 0,
                       5, 5, 5};

  int v[] = {1, 1, 1};
  const size_t kExpected = 0;
  Matrix m = CreateMatrixFromArray(initial_arr, kInitialNRows,
                                   kInitialNCols);
  printf("[--------] n_rows = %zu, n_cols = %zu\n",
         kInitialNRows,
         kInitialNCols);
  printf("[RUN     ]\n");
  assert(GetVectorIndexWithMaxAngle(m, v) == kExpected);

  FreeMemMatrix(&m);
  printf("[      OK]\n");
}

static void test_GetVectorIndexWithMaxAngle() {
  printf("[========] %s()\n", __FUNCTION__);
  test_GetVectorIndexWithMaxAngle_Unique();
  test_GetVectorIndexWithMaxAngle_NotUnique();
}

int main() {
  test_GetVectorIndexWithMaxAngle();

  return 0;
}

#endif // TASK_17

//  *–î–∞–Ω–∞ —Ü–µ–ª–æ—á–∏—Å–ª–µ–Ω–Ω–∞—è –∫–≤–∞–¥—Ä–∞—Ç–Ω–∞—è –º–∞—Ç—Ä–∏—Ü–∞, –≤—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã –∫–æ—Ç–æ—Ä–æ–π —Ä–∞–∑–ª–∏—á–Ω—ã.
//  –ù–∞–π—Ç–∏ —Å–∫–∞–ª—è—Ä–Ω–æ–µ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ —Å—Ç—Ä–æ–∫–∏, –≤ –∫–æ—Ç–æ—Ä–æ–π –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –Ω–∞–∏–±–æ–ª—å—à–∏–π —ç–ª–µ–º–µ–Ω—Ç
//  –º–∞—Ç—Ä–∏—Ü—ã, –Ω–∞ —Å—Ç–æ–ª–±–µ—Ü
#ifdef TASK_18

long long GetScalarProduct(int* v_1,
                           int* v_2,
                           const size_t n) {
  long long scalar_prod = 0;
  for (size_t i = 0; i < n; i++) {
    scalar_prod += v_1[i] * v_2[i];
  }

  return scalar_prod;
}

long long GetScalarProductRowAndCol(const Matrix m,
                                    const size_t init_row_i,
                                    const size_t init_col_i) {
  int* cur_col = (int*) malloc(m.n_rows * sizeof(*cur_col));
  for (size_t row_i = 0; row_i < m.n_rows; row_i++) {
    cur_col[row_i] = m.data[row_i][init_col_i];
  }

  return GetScalarProduct(m.data[init_row_i], cur_col, m.n_cols);
}

long long GetSpecialScalarProduct(const Matrix m) {
  return GetScalarProductRowAndCol(m,
                                   GetMaxValuePos(m).row_i,
                                   GetMinValuePos(m).col_i);
}

static void test_GetSpecialScalarProduct_Simple() {
  printf("[--------] Simple\n");
  const size_t kInitialNRows = 3;
  const size_t kInitialNCols = 3;
  int initial_arr[] = {1, 2, 3,
                       4, 5, 6,
                       7, 8, 9};

  const size_t kExpected = 1 * 7 + 4 * 8 + 7 * 9;
  Matrix m = CreateMatrixFromArray(initial_arr, kInitialNRows,
                                   kInitialNCols);
  printf("[--------] n_rows = %zu, n_cols = %zu\n",
         kInitialNRows,
         kInitialNCols);
  printf("[RUN     ]\n");
  assert(GetSpecialScalarProduct(m) == kExpected);

  FreeMemMatrix(&m);
  printf("[      OK]\n");
}

static void test_GetSpecialScalarProduct_NotSimple() {
  printf("[--------] NotSimple\n");
  const size_t kInitialNRows = 3;
  const size_t kInitialNCols = 3;
  int initial_arr[] = {1, -5, 3,
                       4, 11, 6,
                       7, 0, 9};

  const size_t kExpected = -5 * 4 + 11 * 11;
  Matrix m = CreateMatrixFromArray(initial_arr, kInitialNRows,
                                   kInitialNCols);
  printf("[--------] n_rows = %zu, n_cols = %zu\n",
         kInitialNRows,
         kInitialNCols);
  printf("[RUN     ]\n");
  assert(GetSpecialScalarProduct(m) == kExpected);

  FreeMemMatrix(&m);
  printf("[      OK]\n");
}

static void test_GetSpecialScalarProduct() {
  printf("[========] %s()\n", __FUNCTION__);
  test_GetSpecialScalarProduct_Simple();
  test_GetSpecialScalarProduct_NotSimple();
}

int main() {
  test_GetSpecialScalarProduct();

  return 0;
}

#endif // TASK_18